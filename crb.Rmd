# load data and libraries
```{r}
library(readxl)
library(dplyr)
library(ggplot2)

cr <- read_xlsx("data/CRB eDNA results.xlsx", sheet = "Roller")
cm <- read_xlsx("data/CRB eDNA results.xlsx", sheet = "Mulch")
cr22 <- read_xlsx("data/CRB eDNA results 2022.xlsx", sheet = "Roller")

# Format roller matrix
roll.matrix <- apply(cr[,2:ncol(cr)], 2, as.numeric)
roll.matrix.hits <- roll.matrix
roll.matrix[roll.matrix>0] <- 1

# Format mulch matrix
mulch.matrix <- apply(cm[,2:ncol(cm)], 2, as.numeric)
mulch.matrix.hits <- mulch.matrix
mulch.matrix[mulch.matrix>0] <- 1

# Format both matrix
both.matrix.hits <- cbind(roll.matrix.hits, mulch.matrix.hits)

# Format roller matrix including 2022
roll.matrix22 <- matrix(nrow = 18, ncol = 37)
roll.matrix22[1:16,] <- apply(cr[,2:ncol(cr)], 2, as.numeric)
roll.matrix22[17:18,1:10] <- apply(cr22[,2:ncol(cr22)], 2, as.numeric)
roll.matrix22.hits <- roll.matrix22
roll.matrix22[roll.matrix22>0] <- 1

# Format roller matrix - just high density sites in 2022 & 2023
roll.matrix22high.hits <- roll.matrix22.hits[c(15,17,18),]

# Format 'trap plus roller eDNA' occupancy model
# traproll.array <- simplify2array(list(trap.matrix, eDNA.matrix))
# traproll.matrix <- apply(visroll.array, c(1,2), max)

# Format multilevel eDNAoccupancy model
# make function to expand "number of hits" into 3 columns of 0/1
make_pcr <- function(x){
  na_df <- data.frame(one = NA, two = NA, three = NA)
  if(is.na(x)){return(na_df)}
  else{
  if(x == 0){return(data.frame(one = 0, two = 0, three = 0))}
  if(x == 1){return(data.frame(one = 1, two = 0, three = 0))}
  if(x == 2){return(data.frame(one = 1, two = 1, three = 0))}
  if(x == 3){return(data.frame(one = 1, two = 1, three = 1))}
  }
}

### make a detection/non-detection array - roller only
tlist <- list()
# apply the function to each tree column
for(i in 1:37) {
tlist[[i]] <- sapply(roll.matrix.hits[,i], FUN = make_pcr) %>% t()
}

# create array of PCR detections
y.roll <- array(dim = c(16, 37, 3))
for(i in 1:3){
y.roll[,,i] <- lapply(1:37, FUN = function(x) do.call(c, tlist[[x]][,i])) %>%
  do.call(rbind, .) %>% 
  t()
}

y.roll.mat <- apply(y.roll, c(1,2), max, na.rm = T)
y.roll.mat[is.infinite(y.roll.mat)] <- NA

z.roll = apply(y.roll, 1, max, na.rm = T)
# z.trap = apply(trap.matrix, 1, max, na.rm = T)
# z.both = apply(cbind(z.roll, z.trap), 1, max)

### make a roller detection/non-detection array (including 2022 data)
tlist <- list()
# apply the function to each tree column
for(i in 1:37) {
tlist[[i]] <- sapply(roll.matrix22.hits[,i], FUN = make_pcr) %>% t()
}

# create array of PCR detections
y.roll22 <- array(dim = c(18, 37, 3))
for(i in 1:3){
y.roll22[,,i] <- lapply(1:37, FUN = function(x) do.call(c, tlist[[x]][,i])) %>%
  do.call(rbind, .) %>% 
  t()
}

z.roll22 = apply(y.roll22, 1, max, na.rm = T)
# z.trap = apply(trap.matrix, 1, max, na.rm = T)
# z.both = apply(cbind(z.roll, z.trap), 1, max)

# subset y.roll22 to just the "high density" sites
y.roll22high <- y.roll22[c(15, 17, 18),,]
z.roll22high = apply(y.roll22high, 1, max, na.rm = T)

### make a "both" detection/non-detection array (roller and mulch)
tlist <- list()
# apply the function to each tree column
for(i in 1:ncol(both.matrix.hits)) {
tlist[[i]] <- sapply(both.matrix.hits[,i], FUN = make_pcr) %>% t()
}

# create array of PCR detections
y.both <- array(dim = c(16, ncol(both.matrix.hits), 3))
for(i in 1:3){
y.both[,,i] <- lapply(1:ncol(both.matrix.hits), FUN = function(x) do.call(c, tlist[[x]][,i])) %>%
  do.call(rbind, .) %>% 
  t()
}

y.both.mat <- apply(y.both, c(1,2), max, na.rm = T)
y.both.mat[is.infinite(y.both.mat)] <- NA

z.both = apply(y.both, 1, max, na.rm = T)

# Create array for the covariate "medium density" (1 or 0) for detection (roller only)
mdens.roll.mat <- matrix(c(rep(0, 37*7), 
                 rep(0, 37*4),
                 rep(1, 37*3),
                 rep(0, 37*1),
                 rep(0, 37*1)), ncol = 37, byrow = T)
mdens.roll.array <- simplify2array(list(mdens.roll.mat, mdens.roll.mat, mdens.roll.mat))

# Create array for the covariate "medium density" (1 or 0) for detection (both roller & mulch)
mdens.both.mat <- matrix(c(rep(0, 69*7), 
                 rep(0, 69*4),
                 rep(1, 69*3),
                 rep(0, 69*1),
                 rep(0, 69*1)), ncol = 69, byrow = T)
mdens.both.array <- simplify2array(list(mdens.both.mat, mdens.both.mat, mdens.both.mat))

# Create array for the covariate "high density" (1 or 0) for detection (roller only)
hdens.roll.mat <- matrix(c(rep(0, 37*7), 
                 rep(0, 37*4),
                 rep(0, 37*3),
                 rep(1, 37*1),
                 rep(0, 37*1)), ncol = 37, byrow = T)
hdens.roll.array <- simplify2array(list(hdens.roll.mat, hdens.roll.mat, hdens.roll.mat))

# Create array for the covariate "high density" (1 or 0) for detection (both roller & mulch)
hdens.both.mat <- matrix(c(rep(0, 69*7), 
                 rep(0, 69*4),
                 rep(0, 69*3),
                 rep(1, 69*1),
                 rep(0, 69*1)), ncol = 69, byrow = T)
hdens.both.array <- simplify2array(list(hdens.both.mat, hdens.both.mat, hdens.both.mat))

# Create array for the covariate "high/med density" (1 or 0) for detection (roller only)
hmdens.roll.array <- mdens.roll.array + hdens.roll.array

# Create array for the covariate "high/med density" (1 or 0) for detection (roller & mulch)
hmdens.both.array <- mdens.both.array + hdens.both.array

# Create array for the covariate "roller vs. mulch" (roller & mulch)
roller.mulch <- matrix(nrow = 16, ncol = 69)
for(i in 1:16){
roller.mulch[i,] <- c(rep(1, 37), rep(0, 32))
}
roller.mulch.array <- simplify2array(list(roller.mulch, roller.mulch, roller.mulch))

# Create covariate for 2022 vs. 2023
year.22high <- y.roll22high
year.22high[1,,] <- 1
year.22high[2,,] <- 0
year.22high[3,,] <- 0

# Bundle and summarize data set
jags.data.roll <- list(
  y = y.roll.mat,
  z = ifelse(z.roll > 0, 1, NA),
  n.sites = nrow(y.roll),
  n.trees = ncol(y.roll),
  n.PCRrep = dim(y.roll)[3],
  d = hdens.roll.array+1,
  mdens = mdens.roll.array,
  hdens = hdens.roll.array,
  hmdens = hmdens.roll.array
)

# Bundle and summarize data set
jags.data.roll.qPCR <- list(
  y = y.roll,
  z = rep(1,16), #ifelse(z.roll > 0, 1, NA),
  n.sites = nrow(y.roll),
  n.trees = ncol(y.roll),
  n.PCRrep = dim(y.roll)[3],
  d = hdens.roll.array+1,
  mdens = mdens.roll.array,
  hdens = hdens.roll.array,
  hmdens = hmdens.roll.array
)

# Bundle and summarize data set
jags.data.roll.qPCR.22high <- list(
  y = y.roll22high,
  z = rep(1,3), # mark as present at all sites
  n.sites = nrow(y.roll22high),
  n.trees = ncol(y.roll22high),
  n.PCRrep = dim(y.roll22high)[3],
  year = year.22high
)

# Bundle and summarize data set for "roller & mulch qPCR level"
jags.data.both.qPCR <- list(
  y = y.both,
  z = ifelse(z.both > 0, 1, NA),
  n.sites = nrow(y.both),
  n.trees = ncol(y.both),
  n.PCRrep = dim(y.both)[3],
  mdens = mdens.both.array,
  hdens = hdens.both.array,
  hmdens = hmdens.both.array,
  roller.mulch = roller.mulch.array
)


```

# Define visit-level occupancy model in BUGS language
Can apply to either trap, roll, or mulch detection/non-detection data.
```{r}
sink("scripts/crb_occupancy.txt")
cat("
model {

# Priors
mean.psi ~ dunif(0, 1)        # Occupancy intercept on prob. scale
gamma0 <- logit(mean.psi)      #   same on logit scale
# gamma.mdens ~ dnorm(0, 0.1)   # Covariates on logit(occupancy)
gamma.hdens ~ dnorm(0, 0.1)   # Covariates on logit(occupancy)

mean.p ~ dunif(0, 1)          # Detection intercept on prob. scale
alpha0 <- logit(mean.p)       #   same on logit scale
# alpha.mdens ~ dnorm(0, 0.1)   # Covariates on logit(detection)
alpha.hdens ~ dnorm(0, 0.1)   # Covariates on logit(detection)

# Likelihood
for (i in 1:n.sites) {
  z[i] ~ dbern(psi[i])
  logit(psi[i]) <- gamma0 + #gamma.mdens * mdens[i,1,1] +
                   gamma.hdens * hdens[i,1,1]
   for (j in 1:n.trees) {
      y[i,j] ~ dbern(z[i] * p[i,j])
      logit(p[i,j]) <- alpha0 + #alpha.mdens * mdens[i,j,1] +
                       alpha.hdens * hdens[i,j,1]
   }
}

# Derived quantities
# site-level occupancy for different densities
logit(psi.low) <- gamma0
# logit(psi.med) <- gamma0 + gamma.mdens
logit(psi.high) <- gamma0 + gamma.hdens

# detection probability
logit(p.low) <- alpha0
# logit(p.med) <- alpha0 + alpha.mdens
logit(p.high) <- alpha0 + alpha.hdens

# Cumulative board-level detection probability for 1-37 trees/site
for(i in 1:150){
p_tree_n_low[i] <- (1 - (1 - p.low)^i)
# p_tree_n_med[i] <- (1 - (1 - p.med)^i)
p_tree_n_high[i] <- (1 - (1 - p.high)^i)
}

# trees/site required to reach 95% certainty of detecting skinks within occupied areas
n_low <- log(20) / (-log(1 - p.low))
# n_med <- log(20) / (-log(1 - p.med))
n_high <- log(20) / (-log(1 - p.high))

}

",fill=TRUE)
sink()

```
# Run Visual occupany model in JAGS
```{r}
# Initial values
inits <- function() list(int.psi = runif(1), 
                         int.p = runif(1), 
                         gamma.mdens = rnorm(1, 0, 1),
                         alpha.mdens = rnorm(1,0,1),
                         gamma.hdens = rnorm(1, 0, 1),
                         alpha.hdens = rnorm(1,0,1))

# Parameters monitored
params <- c("gamma0", "gamma.mdens", "gamma.hdens",
            "alpha0", "alpha.mdens", "alpha.hdens",
            "psi.low", "psi.med",
            "psi.high", 
            "p.low", "p.med",
            "p.high",
            "p_tree_n_low", "p_tree_n_med", "p_tree_n_high",
            "n_low", "n_med", "n_high")

#####################################
#### Run jags model
#####################################
crb_roll <- jagsUI::jags(data = jags.data.roll,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_occupancy.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 10000,
                         n.iter = 160000,
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# saveRDS(crb_roll, "output/crb_roll_jags_mod_dens_hl.rds")
crb_roll <- readRDS("output/crb_roll_jags_mod_dens_hl.rds")

# Examine model output
crb_roll

# Examine traceplots
# jagsUI::traceplot(crb_roll)

```
# Run "visual + roller eDNA" occupany model in JAGS
note: it's the identical model to the visual model
```{r}
# # Initial values
# inits <- function() list(int.psi = runif(1), 
#                          int.p = runif(1), 
#                          gamma.season = rnorm(1, 0, 1),
#                          alpha.season = rnorm(1,0,1),
#                          gamma.material = rnorm(1, 0, 1),
#                          alpha.material = rnorm(1,0,1))
# 
# # Parameters monitored
# params <- c("gamma0", "gamma.season", "gamma.material",
#             "alpha0", "alpha.season", "alpha.material",
#             "psi.boards.fall.wood", "psi.boards.spring.wood",
#             "psi.boards.fall.metal", "psi.boards.spring.metal",
#             "p.fall.wood", "p.spring.wood",
#             "p.fall.metal", "p.spring.metal",
#             "p_board_n_spring", "p_board_n_fall",
#             "n_spring", "n_fall")
# 
# #####################################
# #### Run jags model
# #####################################
# skink_visroll <- jagsUI::jags(data = skink.jags.data.visroll,
#                          inits = inits,
#                          parameters.to.save = params,
#                          model.file = "scripts/skink_occupancy.txt",
#                          n.chains = 3,
#                          n.adapt = NULL,
#                          n.burnin = 10000,
#                          n.iter = 160000, 
#                          n.thin = 10,
#                          parallel = T,
#                          verbose = TRUE,
#                          modules = NULL)
# 
# # saveRDS(skink_visroll, "output/skink_visroll_jags_mod_material.rds")
# skink_visroll <- readRDS("output/skink_visroll_jags_mod_material.rds")
# 
# # Examine model output
# # skink_visroll
# 
# # Examine traceplots
# # jagsUI::traceplot(skink_visroll)

```
# Graphing detection probability of trap and "trap + roller eDNA"
```{r}


crb_plot = data.frame(posterior = c(crb_roll$sims.list$p.low,
                         crb_roll$sims.list$p.high
                         ),
           Density = c(rep("Low/med. density", 45000), rep("High density", 45000))
           )
            

# summarize posteriors for plotting medians and 95% CI
crb_post_sum = aggregate(
  crb_plot$posterior,
  list(
    crb_plot$Density
  ),
  median
) %>%
  bind_cols(ll = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$Density
    ),
    FUN = 'quantile',
    probs = c(0.025)
  )$x) %>%
  bind_cols(ul = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$Density
    ),
    FUN = 'quantile',
    probs = c(0.975)
  )$x) %>%
  bind_cols(ll10 = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$Density
    ),
    FUN = 'quantile',
    probs = c(0.1)
  )$x) %>%
  bind_cols(ul90 = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$Density
    ),
    FUN = 'quantile',
    probs = c(0.9)
  )$x) %>%
  rename(
    Density = Group.1,
    med = x
  ) 

crb_plot %>%
  ggplot() +
  ggridges::stat_density_ridges(aes(x = posterior, 
                                     y = Density, 
                                     fill = Density),
                                     quantiles = 2,
                                alpha = 0.75, scale = 1.25) +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll, xmax = ul, 
                                          y = c(0.9,1.9),
                             color = Density), width = 0, size = 0.5) +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll10, xmax = ul90, 
                                          y = c(0.9,1.9),
                             color = Density), width = 0, size = 1) +
  geom_point(data= crb_post_sum, aes(x = med, y = c(0.9,1.9),
                             color = Density), size = 3) +  
  scale_fill_manual(values = c("darkblue", "skyblue")) +
  scale_color_manual(values = c("darkblue", "skyblue")) +
  scale_x_continuous(limits = c(0,0.6)) +
  # facet_wrap(~Density) +
  theme_bw() +
  # ggridges::theme_ridges() +
  theme(text = element_text(size = 14),
        axis.text.y = element_text(size = 15),
        strip.text = element_text(size = 14, vjust=0.5), # vjust=0.9 theme_ridges
        strip.background = element_rect(fill = "transparent",
                                        color = NA),
        axis.title.x = element_text(hjust = 0.5),
        panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA)) +
  labs(x = "Per-sample eDNA detection probability\nat infested site", y = "") +
  coord_cartesian(clip = "off") +
  scale_y_discrete(expand = expand_scale(add = c(.5, 1.5))) +
  guides(fill = "none", color = "none")

 ggsave("figures/crb_roll_detection_probability.jpg",
        dpi = 600, width = 6, height = 4)
```

# Posterior summary statistics for visual-only and visual plus roller eDNA
```{r}
# view point estimates and 95% CI
crb_post_sum

# save table as HTML files
crb_table <- crb_post_sum %>%
  select(1:4) %>%
  mutate(med = med*100,
         ll = ll*100,
         ul = ul*100) %>%
 kableExtra::kbl(caption = "", digits = 1) %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria")

crb_table

# save the table to HTML file
kableExtra::save_kable(crb_table,
           "figures/dp_table.html")

%>%
  cat(., file = "figures/dp_table.html")


```


# Plot cumulative detection probability vs. number of board visits
```{r}

# Format data and create figure
# first load the sum_posts function 
sum_posts = function(x, density = NULL){
  sum_posts_list = aggregate(x, by = list(rep("A", nrow(x))), FUN = function(x) quantile(x, c(0.025, 0.10, 0.5, 0.90, 0.975))) %>%
  select(-Group.1) %>%
  c()

sum_posts_df = do.call("rbind", sum_posts_list) %>% 
  as.data.frame() %>%
  rename(q2.5 = 1, q10 = 2, q50 = 3, q90 = 4, q97.5 = 5) %>%
  mutate(n = 1:length(sum_posts_list),
         Density = density)

return(sum_posts_df)
}

cplot_all <- rbind.data.frame(
sum_posts(crb_roll$sims.list$p_tree_n_low, density = "Low/med. density"),
sum_posts(crb_roll$sims.list$p_tree_n_high, density = "High density")
)

cplot_all %>%
  # filter(n < 65) %>%
  ggplot() +
  geom_abline(slope = 0, intercept = 0.95, color = "darkgray", size=1, linetype = 2) +
  geom_ribbon(aes(x = n, ymin = q2.5, ymax = q97.5, fill = Density),
              alpha = 0.5, color = "transparent") +
  # geom_errorbar(aes(x = n, ymin = q2.5, ymax = q97.5, color = Method),
  #             width = 0, size = 0.5) +  
  # geom_errorbar(aes(x = n, ymin = q10, ymax = q90, color = Method),
  #             width = 0, size = 1) +
  scale_fill_manual(values = c("darkgray", "darkgray")) +
  geom_line(aes(x = n, y = q50, color = Density, linetype = Density), size = 1) +
  # geom_point(aes(x = n, y = q50, color = Density, 
  #                shape = Density), size = 2,
  #            fill = "white") +
  scale_shape_manual(values = c(16,21)) +
  scale_color_manual(values = c("black", "black")) +
  # facet_wrap(~season) +
  theme_bw() +
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 15),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12)) +
  labs(y = "Probability of \u2265 1 detection", 
       x = "Number of trees sampled\nat infested site") +
  theme(strip.text = element_text(
    size = 14,
    colour = "black",
    angle = 0
    ), 
    strip.background = element_rect(fill = "transparent",
                                        color = NA))

# ggsave("figures/crb_cumulative_eDNA_detection.jpg", width = 6, height = 4, dpi = 600)
```



# Define Bayesian qPCR-replicate-based multilevel occ. mod. in JAGS
# version with low vs. high/medium density and roller vs. mulch
JAGS code modified from Kéry & Royle (2015, pp. 606-607).
model from Dorazio & Erickson 2018

Kéry, M., & Royle, J. A. (2015). Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS: Volume 1: Prelude and Static Models. London: Academic Press. 
```{r}
sink("scripts/crb_rollermulch_eDNA_multilevel.txt")
cat("
model {

# Priors and model for params
int.psi ~ dunif(0,1)         # Intercept of occupancy probability
gamma0 <- logit(int.psi)       # same on logit scale
gamma.hmdens ~ dnorm(0, 0.1)   # season covariate on logit(site-level occupancy)

int.theta ~ dunif(0,1)       # Intercept plot-level occupancy probability
beta0 <- logit(int.theta)      # same on logit scale
beta.hmdens ~ dnorm(0, 0.1)   # covariate on logit(tree-level occupancy)
beta.roller.mulch ~ dnorm(0, 0.1) # covariate on logit(tree/sample-level occupancy)

int.p ~ dunif(0,1)           # Intercept detection probability
alpha0 <- logit(int.p)         # same on logit scale
alpha.hmdens ~ dnorm(0, 0.1)   # covariate on logit(detection given DNA capture)
alpha.roller.mulch ~ dnorm(0, 0.1) # covariate on logit(detection given DNA capture)

# Likelihood
for (i in 1:n.sites){
   # Occurrence at board i
   z[i] ~ dbern(psi[i])
   logit(psi[i]) <- gamma0 + gamma.hmdens * hmdens[i,1,1]
   for (j in 1:n.trees){
      # eDNA capture probability (availability) in visit j
      a[i,j] ~ dbern(z[i] * theta[i,j])
       logit(theta[i,j]) <- beta0 + beta.hmdens * hmdens[i,j,1] +
                            beta.roller.mulch * roller.mulch[i,j,1]
      for (k in 1:n.PCRrep){
         # detection process for PCR replicate k
         y[i,j,k] ~ dbern(a[i,j] * p[i,j,k])
         logit(p[i,j,k]) <- alpha0 + alpha.hmdens * hmdens[i,j,k] +
                            alpha.roller.mulch * roller.mulch[i,j,k]
      }
   }
 }

# Derived quantities
# site-level occupancy by density
logit(psi.low) <- gamma0
logit(psi.high) <- gamma0 + gamma.hmdens

# Theta or eDNA capture probability
logit(theta.low.roll) <- beta0 + beta.roller.mulch
logit(theta.low.mulch) <- beta0
logit(theta.high.roll) <- beta0 + beta.hmdens + beta.roller.mulch
logit(theta.high.mulch) <- beta0 + beta.hmdens

# Detection probabity for an individual qPCR replicate
logit(p.low.roll) <- alpha0 + alpha.roller.mulch
logit(p.low.mulch) <- alpha0
logit(p.high.roll) <- alpha0 + alpha.hmdens + alpha.roller.mulch
logit(p.high.mulch) <- alpha0 + alpha.hmdens

# Equation for 'at least one hit' given presence in sample
for(i in 1:6){
p.eDNA_low.roll[i] <- (1-(1-p.low.roll)^i)
p.eDNA_low.mulch[i] <- (1-(1-p.low.mulch)^i)
p.eDNA_high.roll[i] <- (1-(1-p.high.roll)^i)
p.eDNA_high.mulch[i] <- (1-(1-p.high.mulch)^i)
}

# Equation for total detection = capture x probability of 'at least one hit'
for(i in 1:6){
p.eDNA_detect.low.roll[i] <- theta.low.roll * (1-(1-p.low.roll)^i)
p.eDNA_detect.low.mulch[i] <- theta.low.mulch * (1-(1-p.low.mulch)^i)
p.eDNA_detect.high.roll[i] <- theta.high.roll * (1-(1-p.high.roll)^i)
p.eDNA_detect.high.mulch[i] <- theta.high.mulch * (1-(1-p.high.mulch)^i)
}


}
",fill=TRUE)
sink()
```
# Run Bayesian qPCR-replicate-based multilevel occupancy model in JAGS
model from Dorazio & Errickson 2018 (code from Kery & Royle 2015)
```{r}
# Initial values
inits <- function() list(a = apply(y.both, c(1,2), max), 
                         # inits for availability (a)
                         # z = ifelse(z.both>1,as.numeric(1),as.numeric(NA)), # inits for presence (z)
                         int.psi = runif(1), 
                         int.theta = runif(1),
                         int.p = runif(1), 
                         gamma.hmdens = rnorm(1, 0, 1),
                         beta.hmdens = rnorm(1, 0, 1),
                         alpha.hmdens = rnorm(1,0, 1),
                         gamma.roller.mulch = rnorm(1, 0, 1),
                         beta.roller.mulch = rnorm(1, 0, 1),
                         alpha.roller.mulch = rnorm(1,0, 1))

# Parameters monitored
params <- c("gamma0", "gamma.hmdens", 
            "beta0", "beta.hmdens", "beta.roller.mulch",
            "alpha0", "alpha.hmdens", "alpha.roller.mulch",
            "psi.low", "psi.high",
            "theta.low.roll", "theta.low.mulch", 
            "theta.high.roll", "theta.high.mulch", 
            "p.low.roll", "p.low.mulch", 
            "p.high.roll", "p.high.mulch", 
            "p.eDNA_detect.low.roll", "p.eDNA_detect.low.mulch",
            "p.eDNA_detect.high.roll", "p.eDNA_detect.high.mulch",
            "p.eDNA_low.roll", "p.eDNA_low.mulch",
            "p.eDNA_high.roll", "p.eDNA_high.mulch")

#####################################
#### Run jags model
#####################################
crb_eDNApcr <- jagsUI::jags(data = jags.data.both.qPCR,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_rollermulch_eDNA_multilevel.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 20000,
                         n.iter = 120000, 
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# Examine model output
crb_eDNApcr
# saveRDS(skink_eDNA, "output/skink_visroll_jags_mod_materials.rds")
skink_eDNA <- readRDS("output/skink_eDNA_jags_mod_materials.rds")


# Examine traceplots
# jagsUI::traceplot(skink_eDNA)
```
# summarizing posteriors for multilevel roller eDNA JAGS model
qPCR-relplicate detection probability model (Dorazio & Erickson, 2018)
```{r}
# load the multilevel roller eDNA JAGS model
skink_eDNA <- readRDS("output/skink_eDNA_jags_mod_materials.rds")

# 1 tech rep
med_eDNA1 <- t(data.frame(skink_eDNA$q50))[26:29,1]
ll_eDNA1 <- t(data.frame(skink_eDNA$q2.5))[26:29,1]
ul_eDNA1 <- t(data.frame(skink_eDNA$q97.5))[26:29,1]
eDNA_preds1 <- cbind(med_eDNA1, ll_eDNA1, ul_eDNA1)*100

# 2 tech reps
med_eDNA2 <- t(data.frame(skink_eDNA$q50))[26:29,2]
ll_eDNA2 <- t(data.frame(skink_eDNA$q2.5))[26:29,2]
ul_eDNA2 <- t(data.frame(skink_eDNA$q97.5))[26:29,2]
eDNA_preds2 <- cbind(med_eDNA2, ll_eDNA2, ul_eDNA2)*100

# 3 tech reps
med_eDNA3 <- t(data.frame(skink_eDNA$q50))[26:29,3]
ll_eDNA3 <- t(data.frame(skink_eDNA$q2.5))[26:29,3]
ul_eDNA3 <- t(data.frame(skink_eDNA$q97.5))[26:29,3]
eDNA_preds3 <- cbind(med_eDNA3, ll_eDNA3, ul_eDNA3)*100

# 4 tech reps
med_eDNA4 <- t(data.frame(skink_eDNA$q50))[26:29,4]
ll_eDNA4 <- t(data.frame(skink_eDNA$q2.5))[26:29,4]
ul_eDNA4 <- t(data.frame(skink_eDNA$q97.5))[26:29,4]
eDNA_preds4 <- cbind(med_eDNA4, ll_eDNA4, ul_eDNA4)*100

# 5 tech reps
med_eDNA5 <- t(data.frame(skink_eDNA$q50))[26:29,5]
ll_eDNA5 <- t(data.frame(skink_eDNA$q2.5))[26:29,5]
ul_eDNA5 <- t(data.frame(skink_eDNA$q97.5))[26:29,5]
eDNA_preds5 <- cbind(med_eDNA5, ll_eDNA5, ul_eDNA5)*100

# 6 tech reps
med_eDNA6 <- t(data.frame(skink_eDNA$q50))[26:29,6]
ll_eDNA6 <- t(data.frame(skink_eDNA$q2.5))[26:29,6]
ul_eDNA6 <- t(data.frame(skink_eDNA$q97.5))[26:29,6]
eDNA_preds6 <- cbind(med_eDNA6, ll_eDNA6, ul_eDNA6)*100

cbind(eDNA_preds1, eDNA_preds2, eDNA_preds3, eDNA_preds4, eDNA_preds5, eDNA_preds6) %>%
  t() %>%
  as.data.frame() %>%
  knitr::kable(format = "html", digits = 1) %>%
  cat(., file = "tables/tableS3A.html")

```



# Define Bayesian qPCR-replicate-based multilevel occ. mod. in JAGS
# version with low vs. high/medium density and ROLLER ONLY
JAGS code modified from Kéry & Royle (2015, pp. 606-607).
model from Dorazio & Erickson 2018

Kéry, M., & Royle, J. A. (2015). Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS: Volume 1: Prelude and Static Models. London: Academic Press. 
```{r}
sink("scripts/crb_roller_eDNA_multilevel.txt")
cat("
model {

# Priors and model for params
int.psi ~ dunif(0,1)         # Intercept of occupancy probability
gamma0 <- logit(int.psi)       # same on logit scale
gamma.hmdens ~ dnorm(0, 0.1)   # season covariate on logit(site-level occupancy)

int.theta ~ dunif(0,1)       # Intercept plot-level occupancy probability
beta0 <- logit(int.theta)      # same on logit scale
beta.hmdens ~ dnorm(0, 0.1)   # covariate on logit(tree-level occupancy)
# beta.roller.mulch ~ dnorm(0, 0.1) # covariate on logit(tree/sample-level occupancy)

int.p ~ dunif(0,1)           # Intercept detection probability
alpha0 <- logit(int.p)         # same on logit scale
alpha.hmdens ~ dnorm(0, 0.1)   # covariate on logit(detection given DNA capture)
# alpha.roller.mulch ~ dnorm(0, 0.1) # covariate on logit(detection given DNA capture)

# Likelihood
for (i in 1:n.sites){
   # Occurrence at board i
   z[i] ~ dbern(psi[i])
   logit(psi[i]) <- gamma0 + gamma.hmdens * hmdens[i,1,1]
   for (j in 1:n.trees){
      # eDNA capture probability (availability) in visit j
      a[i,j] ~ dbern(z[i] * theta[i,j])
       logit(theta[i,j]) <- beta0 + beta.hmdens * hmdens[i,j,1]
      for (k in 1:n.PCRrep){
         # detection process for PCR replicate k
         y[i,j,k] ~ dbern(a[i,j] * p[i,j,k])
         logit(p[i,j,k]) <- alpha0 + alpha.hmdens * hmdens[i,j,k]
      }
   }
 }

# Derived quantities
# site-level occupancy by density
logit(psi.low) <- gamma0
logit(psi.high) <- gamma0 + gamma.hmdens

# Theta or eDNA capture probability
logit(theta.low.roll) <- beta0
logit(theta.high.roll) <- beta0 + beta.hmdens

# Detection probabity for an individual qPCR replicate
logit(p.low.roll) <- alpha0
logit(p.high.roll) <- alpha0 + alpha.hmdens

# Equation for 'at least one hit' given presence in sample
for(i in 1:8){
p.eDNA_low.roll[i] <- (1-(1-p.low.roll)^i)
p.eDNA_high.roll[i] <- (1-(1-p.high.roll)^i)
}

# Equation for total detection = capture x probability of 'at least one hit' w/ 8 tech reps
for(i in 1:30){
p.eDNA_detect.low.roll[i] <- 1-(1-(theta.low.roll * (1-(1-p.low.roll)^8)))^i
p.eDNA_detect.high.roll[i] <- 1-(1-(theta.high.roll * (1-(1-p.high.roll)^8)))^i
}


}
",fill=TRUE)
sink()
```
# Run Bayesian qPCR-replicate-based multilevel occupancy model in JAGS
model from Dorazio & Errickson 2018 (code from Kery & Royle 2015)
```{r}
# Initial values
inits <- function() list(a = apply(y.roll, c(1,2), max), 
                         # inits for availability (a)
                         # z = ifelse(z.both>1,as.numeric(1),as.numeric(NA)), # inits for presence (z)
                         int.psi = runif(1), 
                         int.theta = runif(1),
                         int.p = runif(1), 
                         gamma.hmdens = rnorm(1, 0, 1),
                         beta.hmdens = rnorm(1, 0, 1),
                         alpha.hmdens = rnorm(1,0, 1),
                         gamma.roller.mulch = rnorm(1, 0, 1),
                         beta.roller.mulch = rnorm(1, 0, 1),
                         alpha.roller.mulch = rnorm(1,0, 1))

# Parameters monitored
params <- c("gamma0", "gamma.hmdens", 
            "beta0", "beta.hmdens", "beta.roller.mulch",
            "alpha0", "alpha.hmdens", "alpha.roller.mulch",
            "psi.low", "psi.high",
            "theta.low.roll", "theta.low.mulch", 
            "theta.high.roll", "theta.high.mulch", 
            "p.low.roll", "p.low.mulch", 
            "p.high.roll", "p.high.mulch", 
            "p.eDNA_detect.low.roll", "p.eDNA_detect.low.mulch",
            "p.eDNA_detect.high.roll", "p.eDNA_detect.high.mulch",
            "p.eDNA_low.roll", "p.eDNA_low.mulch",
            "p.eDNA_high.roll", "p.eDNA_high.mulch")

#####################################
#### Run jags model
#####################################
crb_eDNA <- jagsUI::jags(data = jags.data.roll.qPCR,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_roller_eDNA_multilevel.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 20000,
                         n.iter = 120000, 
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# Examine model output
crb_eDNA
# saveRDS(crb_eDNA, "output/crb_qPCR_roll_jags_mod_density.rds")
crb_eDNA <- readRDS("output/crb_qPCR_roll_jags_mod_density.rds")


# Examine traceplots
# jagsUI::traceplot(skink_eDNA)
```
# summarizing posteriors for multilevel roller eDNA JAGS model
qPCR-relplicate detection probability model (Dorazio & Erickson, 2018)
```{r}
# load the multilevel roller eDNA JAGS model
# crb_eDNA <- readRDS("output/skink_eDNA_jags_mod_materials.rds")

# tech reps (low dens)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_low.roll)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_low.roll)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_low.roll)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_low.roll, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_low.roll, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high/med dens)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(techreps = c(1:8,1:8),
         dens = c(rep("Low density", 8), rep("High density", 8)))

(techreps_plot <- df %>%
  ggplot() +
  geom_errorbar(aes(x = techreps, ymin = ll, ymax = ul, color = dens),
                position = position_dodge(width = 1),
                width = 0) +
  geom_errorbar(aes(x = techreps, ymin = ll10, ymax = ul90, color = dens),
                position = position_dodge(width = 1),
                width = 0, linewidth = 1) +
  geom_point(aes(x = techreps, y = med, color = dens),
                position = position_dodge(width = 1),
             size = 3) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "Technical replicates",
       y = "Detection prob. given eDNA capture\nwithin sample",
       color = "") +
  theme_bw() +
    guides(color = "none")
)

# num samples at 8 tech reps (low dens)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.low.roll)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.low.roll)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.low.roll)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.low.roll, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.low.roll, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high/med dens)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.high.roll)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.high.roll)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.high.roll)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df_samps <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(numsamps = c(1:100,1:100),
         dens = c(rep("Low density", 100), rep("High/med. density", 100)))

(samps_plot <- df_samps %>%
  ggplot() +
  geom_ribbon(aes(x = numsamps, ymin = ll, ymax = ul, fill = dens),
                position = position_dodge(width = 1),
              alpha = 0.5) +
  geom_ribbon(aes(x = numsamps, ymin = ll10, ymax = ul90, fill = dens),
                position = position_dodge(width = 1),
              alpha = 0.5) +
  geom_line(aes(x = numsamps, y = med, color = dens), linewidth = 1) +
  scale_fill_manual(values = c("olivedrab", "steelblue")) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "No. samples (at 8 tech. replicates)",
       y = "Cumulative detection probability\nat infested site (%)",
       fill = "",
       color = "") +
  theme_bw() +
  theme(text = element_text(size = 12))
)

library(patchwork)

techreps_plot + samps_plot

ggsave("figures/model_with_qPCRrep2.jpg", width = 9, height = 4, dpi = 400)
```







# Year 2022 vs. 2023 at high-density sites

# Define Bayesian qPCR-replicate-based multilevel occ. mod. in JAGS
# version with low vs. high density and ROLLER ONLY, 2022 vs. 2023
JAGS code modified from Kéry & Royle (2015, pp. 606-607).
model from Dorazio & Erickson 2018

Kéry, M., & Royle, J. A. (2015). Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS: Volume 1: Prelude and Static Models. London: Academic Press. 
```{r}
sink("scripts/crb_roller_eDNA_multilevel_year.txt")
cat("
model {

# Priors and model for params
int.psi ~ dunif(0,1)         # Intercept of occupancy probability
gamma0 <- logit(int.psi)       # same on logit scale

int.theta ~ dunif(0,1)       # Intercept plot-level occupancy probability
beta0 <- logit(int.theta)      # same on logit scale
beta.year ~ dnorm(0, 0.1)   # covariate on logit(tree-level occupancy)

int.p ~ dunif(0,1)           # Intercept detection probability
alpha0 <- logit(int.p)         # same on logit scale
alpha.year ~ dnorm(0, 0.1)   # covariate on logit(detection given DNA capture)

# Likelihood
for (i in 1:n.sites){
   # Occurrence at board i
   # z[i] ~ dbern(psi[i])
   # logit(psi[i]) <- gamma0
   for (j in 1:n.trees){
      # eDNA capture probability (availability) in visit j
      a[i,j] ~ dbern(z[i] * theta[i,j])
       logit(theta[i,j]) <- beta0 + beta.year * year[i,j,1]
      for (k in 1:n.PCRrep){
         # detection process for PCR replicate k
         y[i,j,k] ~ dbern(a[i,j] * p[i,j,k])
         logit(p[i,j,k]) <- alpha0 + alpha.year * year[i,j,k]
      }
   }
 }

# Derived quantities
# site-level occupancy by density
logit(psi.high) <- gamma0

# Theta or eDNA capture probability
logit(theta.high.roll22) <- beta0
logit(theta.high.roll23) <- beta0 + beta.year

# Detection probabity for an individual qPCR replicate
logit(p.high.roll22) <- alpha0
logit(p.high.roll23) <- alpha0 + alpha.year

# Equation for 'at least one hit' given presence in sample
for(i in 1:8){
p.eDNA_high.roll22[i] <- (1-(1-p.high.roll22)^i)
p.eDNA_high.roll23[i] <- (1-(1-p.high.roll23)^i)
}

# Equation for total detection = capture x probability of 'at least one hit' w/ 8 tech reps
for(i in 1:20){
p.eDNA_detect.high.roll22[i] <- 1-(1-(theta.high.roll22 * (1-(1-p.high.roll22)^8)))^i
p.eDNA_detect.high.roll23[i] <- 1-(1-(theta.high.roll23 * (1-(1-p.high.roll23)^8)))^i
}


}
",fill=TRUE)
sink()
```
# Run Bayesian qPCR-replicate-based multilevel occupancy model in JAGS
model from Dorazio & Errickson 2018 (code from Kery & Royle 2015)
```{r}
# Initial values
inits <- function() list(a = apply(y.roll22high, c(1,2), max), 
                         # inits for availability (a)
                         # z = ifelse(z.both>1,as.numeric(1),as.numeric(NA)), # inits for presence (z)
                         int.psi = runif(1), 
                         int.theta = runif(1),
                         int.p = runif(1), 
                         gamma.hmdens = rnorm(1, 0, 1),
                         beta.hmdens = rnorm(1, 0, 1),
                         alpha.hmdens = rnorm(1,0, 1),
                         gamma.roller.mulch = rnorm(1, 0, 1),
                         beta.roller.mulch = rnorm(1, 0, 1),
                         alpha.roller.mulch = rnorm(1,0, 1))

# Parameters monitored
params <- c("gamma0", 
            "beta0", "beta.year", 
            "alpha0", "alpha.year", 
            "psi.low", "psi.high",
            "theta.high.roll22", 
            "theta.high.roll23", 
            "p.high.roll22", 
            "p.high.roll23", 
            "p.eDNA_detect.high.roll22", 
            "p.eDNA_detect.high.roll23", 
            "p.eDNA_high.roll22", 
            "p.eDNA_high.roll23")

#####################################
#### Run jags model
#####################################
crb_eDNA22high <- jagsUI::jags(data = jags.data.roll.qPCR.22high,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_roller_eDNA_multilevel_year.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 20000,
                         n.iter = 120000, 
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# Examine model output
crb_eDNA22high
# saveRDS(crb_eDNA, "output/crb_qPCR_roll_jags_mod_density.rds")
crb_eDNA <- readRDS("output/crb_qPCR_roll_jags_mod_density.rds")


# Examine traceplots
# jagsUI::traceplot(skink_eDNA)
```
# summarizing posteriors for multilevel roller eDNA JAGS model
qPCR-relplicate detection probability model (Dorazio & Erickson, 2018)
```{r}
# load the multilevel roller eDNA JAGS model
# crb_eDNA <- readRDS("output/skink_eDNA_jags_mod_materials.rds")
crb_eDNA <- crb_eDNA22high

# tech reps (high dens 2022)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll22)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll22)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll22)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll22, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll22, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high dens 2023)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll23)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll23)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll23)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll23, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll23, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(techreps = c(1:8,1:8),
         dens = c(rep("2022", 8), rep("2023", 8)))

(techreps_plot <- df %>%
  ggplot() +
  geom_errorbar(aes(x = techreps, ymin = ll, ymax = ul, color = dens),
                position = position_dodge(width = 1),
                width = 0) +
  geom_errorbar(aes(x = techreps, ymin = ll10, ymax = ul90, color = dens),
                position = position_dodge(width = 1),
                width = 0, linewidth = 1) +
  geom_point(aes(x = techreps, y = med, color = dens),
                position = position_dodge(width = 1),
             size = 3) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "Technical replicates",
       y = "Detection prob. given eDNA capture\nwithin sample",
       color = "") +
  theme_bw() +
    guides(color = "none")
)

# num samples at 8 tech reps (high dens 2022)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.high.roll22)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.high.roll22)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.high.roll22)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll22, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll22, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high dens 2023)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.high.roll23)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.high.roll23)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.high.roll23)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll23, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll23, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df_samps <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(numsamps = c(1:100,1:100),
         dens = c(rep("2022", 100), rep("2023", 100)))

(samps_plot <- df_samps %>%
    filter(numsamps < 21) %>%
  ggplot() +
  geom_ribbon(aes(x = numsamps, ymin = ll, ymax = ul, fill = dens),
                position = position_dodge(width = 1),
              alpha = 0.5) +
  # geom_ribbon(aes(x = numsamps, ymin = ll10, ymax = ul90, fill = dens),
  #               position = position_dodge(width = 1),
  #             alpha = 0.5) +
  geom_line(aes(x = numsamps, y = med, color = dens), linewidth = 1) +
  scale_fill_manual(values = c("olivedrab", "steelblue")) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "No. samples (at 8 tech. replicates)",
       y = "Cumulative detection probability\nat infested site (%)",
       fill = "",
       color = "") +
  theme_bw() +
  theme(text = element_text(size = 12))
)

library(patchwork)

techreps_plot + samps_plot

ggsave("figures/model_with_qPCRrep_highdensityonly_2022_2023.jpg", width = 9, height = 4, dpi = 400)
```