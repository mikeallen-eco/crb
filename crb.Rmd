# load data and libraries
```{r}
library(readxl)
library(dplyr)
library(ggplot2)
library(stringr)
library(lubridate)

cr <- read_xlsx("data/CRB eDNA results.xlsx", sheet = "Roller")
cm <- read_xlsx("data/CRB eDNA results.xlsx", sheet = "Mulch")
cr22 <- read_xlsx("data/CRB eDNA results 2022.xlsx", sheet = "Roller")
cm22 <- read_xlsx("data/CRB eDNA results 2022.xlsx", sheet = "Mulch")
options(digits = 9)
sites <- read_xlsx("data/April 2023 CRB eDNA site locations.xlsx", sheet = "Sheet1") %>%
  mutate(lat = as.numeric(str_sub(GPS, 1,8)),
         lon = -1*as.numeric(str_sub(gsub(GPS, pattern = "W", replacement = ""), 12,21), digits = 9))
# 3 mo +/- is ~ [13, 193]
# 2 mo is ~ 43,163
# 1 mo is 73,133

# Format roller matrix
roll.matrix <- apply(cr[,2:ncol(cr)], 2, as.numeric)
roll.matrix.hits <- roll.matrix
roll.matrix[roll.matrix>0] <- 1

# Format mulch matrix
mulch.matrix <- apply(cm[,2:ncol(cm)], 2, as.numeric)
mulch.matrix.hits <- mulch.matrix
mulch.matrix[mulch.matrix>0] <- 1

# Format both matrix
both.matrix.hits <- cbind(roll.matrix.hits, mulch.matrix.hits)

# Format roller matrix including 2022
roll.matrix22 <- matrix(nrow = 18, ncol = 37)
roll.matrix22[1:16,] <- apply(cr[,2:ncol(cr)], 2, as.numeric)
roll.matrix22[17:18,1:10] <- apply(cr22[,2:ncol(cr22)], 2, as.numeric)
roll.matrix22.hits <- roll.matrix22
roll.matrix22[roll.matrix22>0] <- 1

# Format mulch matrix including 2022
mulch.matrix22high <- matrix(nrow = 2, ncol = 11)
mulch.matrix22high[1,1:10] <- apply(cm[15,2:11], 2, as.numeric)
mulch.matrix22high[2,1:11] <- apply(cm22[1,2:ncol(cm22)], 2, as.numeric)
mulch.matrix22high.hits <- mulch.matrix22high
mulch.matrix22high[mulch.matrix22high>0] <- 1

# Format roller matrix - just high density sites in 2022 & 2023
roll.matrix22high.hits <- roll.matrix22.hits[c(15,17,18),]

# Format 'trap plus roller eDNA' occupancy model
# traproll.array <- simplify2array(list(trap.matrix, eDNA.matrix))
# traproll.matrix <- apply(visroll.array, c(1,2), max)

# Format multilevel eDNAoccupancy model
# make function to expand "number of hits" into 3 columns of 0/1
make_pcr <- function(x){
  na_df <- data.frame(one = NA, two = NA, three = NA)
  if(is.na(x)){return(na_df)}
  else{
  if(x == 0){return(data.frame(one = 0, two = 0, three = 0))}
  if(x == 1){return(data.frame(one = 1, two = 0, three = 0))}
  if(x == 2){return(data.frame(one = 1, two = 1, three = 0))}
  if(x == 3){return(data.frame(one = 1, two = 1, three = 1))}
  }
}

### make a detection/non-detection array - roller only
tlist <- list()
# apply the function to each tree column
for(i in 1:37) {
tlist[[i]] <- sapply(roll.matrix.hits[,i], FUN = make_pcr) %>% t()
}

# create array of PCR detections
y.roll <- array(dim = c(16, 37, 3))
for(i in 1:3){
y.roll[,,i] <- lapply(1:37, FUN = function(x) do.call(c, tlist[[x]][,i])) %>%
  do.call(rbind, .) %>% 
  t()
}

y.roll.mat <- apply(y.roll, c(1,2), max, na.rm = T)
y.roll.mat[is.infinite(y.roll.mat)] <- NA

z.roll = apply(y.roll, 1, max, na.rm = T)
# z.trap = apply(trap.matrix, 1, max, na.rm = T)
# z.both = apply(cbind(z.roll, z.trap), 1, max)

### make a roller detection/non-detection array (including 2022 data)
tlist <- list()
# apply the function to each tree column
for(i in 1:37) {
tlist[[i]] <- sapply(roll.matrix22.hits[,i], FUN = make_pcr) %>% t()
}

# create array of PCR detections
y.roll22 <- array(dim = c(18, 37, 3))
for(i in 1:3){
y.roll22[,,i] <- lapply(1:37, FUN = function(x) do.call(c, tlist[[x]][,i])) %>%
  do.call(rbind, .) %>% 
  t()
}

z.roll22 = apply(y.roll22, 1, max, na.rm = T)
# z.trap = apply(trap.matrix, 1, max, na.rm = T)
# z.both = apply(cbind(z.roll, z.trap), 1, max)

### make a mulch detection/non-detection array (including 2022 data)
tlist <- list()
# apply the function to each tree column
for(i in 1:11) {
tlist[[i]] <- sapply(mulch.matrix22high.hits[,i], FUN = make_pcr) %>% t()
}

# create array of PCR detections
y.mulch22high <- array(dim = c(2, 11, 3))
for(i in 1:3){
y.mulch22high[,,i] <- lapply(1:11, FUN = function(x) do.call(c, tlist[[x]][,i])) %>%
  do.call(rbind, .) %>%
  t()
}

z.mulch22high = apply(y.mulch22high, 1, max, na.rm = T)

# subset y.roll22 to just the "high density" sites
y.roll22high <- y.roll22[c(15, 17, 18),,]
z.roll22high = apply(y.roll22high, 1, max, na.rm = T)

### make a "both" detection/non-detection array (roller and mulch)
tlist <- list()
# apply the function to each tree column
for(i in 1:ncol(both.matrix.hits)) {
tlist[[i]] <- sapply(both.matrix.hits[,i], FUN = make_pcr) %>% t()
}

# create array of PCR detections
y.both <- array(dim = c(16, ncol(both.matrix.hits), 3))
for(i in 1:3){
y.both[,,i] <- lapply(1:ncol(both.matrix.hits), FUN = function(x) do.call(c, tlist[[x]][,i])) %>%
  do.call(rbind, .) %>% 
  t()
}

y.both.mat <- apply(y.both, c(1,2), max, na.rm = T)
y.both.mat[is.infinite(y.both.mat)] <- NA

z.both = apply(y.both, 1, max, na.rm = T)

# Create array for the covariate "medium density" (1 or 0) for detection (roller only)
mdens.roll.mat <- matrix(c(rep(0, 37*7), 
                 rep(0, 37*4),
                 rep(1, 37*3),
                 rep(0, 37*1),
                 rep(0, 37*1)), ncol = 37, byrow = T)
mdens.roll.array <- simplify2array(list(mdens.roll.mat, mdens.roll.mat, mdens.roll.mat))

# Create array for the covariate "medium density" (1 or 0) for detection (both roller & mulch)
mdens.both.mat <- matrix(c(rep(0, 69*7), 
                 rep(0, 69*4),
                 rep(1, 69*3),
                 rep(0, 69*1),
                 rep(0, 69*1)), ncol = 69, byrow = T)
mdens.both.array <- simplify2array(list(mdens.both.mat, mdens.both.mat, mdens.both.mat))

# Create array for the covariate "high density" (1 or 0) for detection (roller only)
hdens.roll.mat <- matrix(c(rep(0, 37*7), 
                 rep(0, 37*4),
                 rep(0, 37*3),
                 rep(1, 37*1),
                 rep(0, 37*1)), ncol = 37, byrow = T)
hdens.roll.array <- simplify2array(list(hdens.roll.mat, hdens.roll.mat, hdens.roll.mat))

# Create array for the covariate "high density" (1 or 0) for detection (both roller & mulch)
hdens.both.mat <- matrix(c(rep(0, 69*7), 
                 rep(0, 69*4),
                 rep(0, 69*3),
                 rep(1, 69*1),
                 rep(0, 69*1)), ncol = 69, byrow = T)
hdens.both.array <- simplify2array(list(hdens.both.mat, hdens.both.mat, hdens.both.mat))

# Create array for the covariate "high/med density" (1 or 0) for detection (roller only)
hmdens.roll.array <- mdens.roll.array + hdens.roll.array

# Create array for the covariate "high/med density" (1 or 0) for detection (roller & mulch)
hmdens.both.array <- mdens.both.array + hdens.both.array

# Create array for the covariate "roller vs. mulch" (roller & mulch)
roller.mulch <- matrix(nrow = 16, ncol = 69)
for(i in 1:16){
roller.mulch[i,] <- c(rep(1, 37), rep(0, 32))
}
roller.mulch.array <- simplify2array(list(roller.mulch, roller.mulch, roller.mulch))

# Create covariate for 2022 vs. 2023
year.22high <- y.roll22high
year.22high[1,,] <- 1
year.22high[2,,] <- 0
year.22high[3,,] <- 0

# Create covariate for 2022 vs. 2023 for mulch
year.22high.mulch <- year.22high[1:2,1:11,]

# Bundle and summarize data set
jags.data.roll <- list(
  y = y.roll.mat,
  z = ifelse(z.roll > 0, 1, NA),
  n.sites = nrow(y.roll),
  n.trees = ncol(y.roll),
  n.PCRrep = dim(y.roll)[3],
  d = hdens.roll.array+1,
  mdens = mdens.roll.array,
  hdens = hdens.roll.array,
  hmdens = hmdens.roll.array
)

# Bundle and summarize data set
jags.data.roll.qPCR <- list(
  y = y.roll,
  z = rep(1,16), #ifelse(z.roll > 0, 1, NA),
  n.sites = nrow(y.roll),
  n.trees = ncol(y.roll),
  n.PCRrep = dim(y.roll)[3],
  d = hdens.roll.array+1,
  mdens = mdens.roll.array,
  hdens = hdens.roll.array,
  hmdens = hmdens.roll.array
)

# Bundle and summarize data set
jags.data.roll.qPCR.22high <- list(
  y = y.roll22high,
  z = rep(1,3), # mark as present at all sites
  n.sites = nrow(y.roll22high),
  n.trees = ncol(y.roll22high),
  n.PCRrep = dim(y.roll22high)[3],
  year = year.22high
)

# Bundle and summarize data set
jags.data.mulch.qPCR.22high <- list(
  y = y.mulch22high,
  z = rep(1,2), # mark as present at all sites
  n.sites = nrow(y.mulch22high),
  n.trees = ncol(y.mulch22high),
  n.PCRrep = dim(y.mulch22high)[3],
  year = year.22high.mulch
)

# Bundle and summarize data set for "roller & mulch qPCR level"
jags.data.both.qPCR <- list(
  y = y.both,
  z = ifelse(z.both > 0, 1, NA),
  n.sites = nrow(y.both),
  n.trees = ncol(y.both),
  n.PCRrep = dim(y.both)[3],
  mdens = mdens.both.array,
  hdens = hdens.both.array,
  hmdens = hmdens.both.array,
  roller.mulch = roller.mulch.array
)

#########
## Load and format trap data
#########

tn1 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "Hau_ulaSite1_ExportTable")
tn2 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "Punalu_uSite1_ExportTable")
tn3 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "Punalu_uSite2_ExportTable")
tn4 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "Punalu_uSite3_ExportTable")
tn5 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "Punalu_uSite4_ExportTable")
tn6 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "WaimanaloSite1_ExportTable")
tn7 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "WaimanaloSite2_ExportTable")
tn8 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "WaimanaloSite3_ExportTable")
tn9 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "WaimanaloSite4_ExportTable")
tn10 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "WaimanaloSite5_ExportTable")
tn11 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "WaimanaloSite6_ExportTable")
tn12 <- read_xls("data/NegativeCRBDatawithinSampleSiteBuffers.xls", sheet = "HawaiiKaiSite1_ExportTable")

tn <- bind_rows(tn1, tn2, tn3, tn4, tn5, tn6, tn7, tn8, tn9, tn10, tn11, tn12) %>%
  select(-OBJECTID) %>%
  distinct()

# import trap detections

tp1 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "KaneoheSite1_ExportTable")
tp2 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "Hau_ulaSite1_ExportTable")
tp3 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "Hau_ulaSite2_ExportTable")
tp4 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "Hau_ulaSite3_ExportTable")
tp5 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "Hau_ulaSite4_ExportTable")
tp6 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "Punalu_uSite1_ExportTable")
tp7 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "Punalu_uSite2_ExportTable")
tp8 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "Punalu_uSite3_ExportTable")
tp9 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", sheet = "Punalu_uSite4_ExportTable")
tp10 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", 
                sheet = "WaimanaloSite1_ExportTable")
tp11 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", 
                sheet = "WaimanaloSite2_ExportTable")
tp12 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", 
                sheet = "WaimanaloSite3_ExportTable")
tp13 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", 
                sheet = "WaimanaloSite4_ExportTable")
tp14 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", 
                sheet = "WaimanaloSite5_ExportTable")
tp15 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", 
                sheet = "WaimanaloSite6_ExportTable")
tp16 <- read_xls("data/CRB Trap Finds within eDNA Sample Sites.xls", 
                sheet = "HawaiiKaiSite1_ExportTable")

tp <- bind_rows(tp1, tp2, tp3, tp4, tp5, tp6, tp7, tp8, tp9, tp10, tp11, tp12,
                tp13, tp14, tp15, tp16) %>%
  select(-OBJECTID) %>%
  distinct()

rm(tn1, tn2, tn3, tn4, tn5, tn6, tn7, tn8, tn9, tn10, tn11, tn12, 
   tp1, tp2, tp3, tp4, tp5, tp6, tp7, tp8, tp9, tp10, tp11, tp12,
                tp13, tp14, tp15, tp16)

# bind trap detection and non-detection data together and format
tn_tmp <- tn %>%
  select(id = Location_N, lat = Latitude, lon = Longitude, 
         Deploy_Dat, Activity_D, type = Tool_Name) %>%
  mutate(deploy_date = ymd(Deploy_Dat),
         check_date = ymd(Activity_D),
         det = 0,
         stage = "NA") %>%
  select(-Activity_D, -Deploy_Dat)

tp_tmp <- tp %>%
    select(id = Location_Name, lat = Latitude, lon = Longitude, 
         Date_Assigned, type = Tool_Name, stage = CRB_Class) %>%
  mutate(date_tmp = str_sub(Date_Assigned,1,10),
         check_date = ymd(date_tmp),
         det = 1) %>%
  select(-Date_Assigned, -date_tmp)

tt <- tn_tmp %>%
  bind_rows(tp_tmp) %>%
  select(-stage) %>% # remove M/F info for now
  group_by(id, lat, lon, type, deploy_date, check_date, det) %>%
  summarize(num = sum(det),
            .groups = "drop") %>%
    arrange(id, check_date) %>%
  mutate(lon = -1*abs(lon),
         check_ord = yday(check_date),
         mo3 = case_when(check_ord %in% 13:193 ~ 1,
                         TRUE ~ 0),
         mo1 = case_when(check_ord %in% 73:133 ~ 1,
                         TRUE ~ 0))

library(sf)

sites.sf <- sites %>%
  st_as_sf(coords = c("lon", "lat"),
           crs = 4326)

plot(sites.sf[,"Site"])

sites.sf.1k <- sites.sf %>%
  st_buffer(dist = 500)

tt3 <- tt %>%
  st_as_sf(coords = c("lon", "lat"),
           crs = 4326) %>%
  st_join(sites.sf.1k) %>%
  filter(!is.na(GPS)) %>%
  filter(mo3 ==1) %>%
  # as.data.frame() %>%
  group_by(id, Site) %>%
  tidyr::replace_na(list(deploy_date = ymd("1900-01-01"))) %>%
  summarize(any_dets = max(det),
            num_dets = sum(det),
            num_checks = length(check_ord),
            tot_indiv = sum(num),
            mincheck = min(check_ord),
            maxcheck = max(check_ord),
            deploy_yr = max(year(deploy_date)),
            deploy_ord = max(yday(deploy_date)),
            .groups = "drop"
            ) %>%
  mutate(deploy_dur = case_when(((deploy_yr == 2023) & (deploy_ord < 13)) ~ maxcheck-13,
                                ((deploy_yr == 2023) & (deploy_ord >= 13)) ~ maxcheck-mincheck,
                                (deploy_yr < 2023) ~ maxcheck-13)) %>%
  rename(site = Site) %>%
  arrange(site, id)

tt1 <- tt %>%
  st_as_sf(coords = c("lon", "lat"),
           crs = 4326) %>%
  st_join(sites.sf.1k) %>%
  filter(!is.na(GPS)) %>%
  filter(mo3 ==1) %>%
  # as.data.frame() %>%
  group_by(id, Site) %>%
  tidyr::replace_na(list(deploy_date = ymd("1900-01-01"))) %>%
  summarize(any_dets = max(det),
            num_dets = sum(det),
            num_checks = length(check_ord),
            tot_indiv = sum(num),
            mincheck = min(check_ord),
            maxcheck = max(check_ord),
            deploy_yr = max(year(deploy_date)),
            deploy_ord = max(yday(deploy_date)),
            .groups = "drop"
            ) %>%
  mutate(deploy_dur = case_when(((deploy_yr == 2023) & (deploy_ord < 73)) ~ maxcheck-73,
                                ((deploy_yr == 2023) & (deploy_ord >= 73)) ~ maxcheck-mincheck,
                                (deploy_yr < 2023) ~ maxcheck-73)) %>%
  rename(site = Site) %>%
  arrange(site, id)

ggplot(sites.sf.1k) +
  geom_sf() +
  # geom_sf(data = sites.sf, color = "black", size = 1) +
  geom_sf(data = tt3, color = "red", size = 0.5)


tt1.dets = tt1 %>%
  as.data.frame() %>%
  group_by(site) %>%
  mutate(visit = paste0("T", 1:length(site))) %>%
  select(site, any_dets, visit) %>%
  tidyr::pivot_wider(id_cols = site, names_from = visit, values_from = any_dets)

# combine roller, mulch, and trap (3 mo) data into one big matrix
call <- cr %>%
  left_join(cm) %>%
  rename(site = Site) %>%
  left_join(tt3.dets)

call.mat1 <- call %>%
  select(-site) %>%
  as.matrix() %>%
  as.numeric() %>%
  matrix(nrow = 16, ncol = 85)
call.mat <- call.mat1
call.mat[call.mat1>0] <- 1

# add 3 rows of NAs on the bottom to make room for 2022 roller and mulch samples
call.mat1b <- call.mat1 %>%
  rbind(matrix(NA, nrow = 2, ncol = 85))
add_to_cm22 <- matrix(NA, nrow = 1, ncol = 11)

cmcr22 <- matrix(NA, nrow = 16, ncol = 21) %>%
  rbind(
    cbind(as.matrix(cr22[,2:11]), rbind(add_to_cm22, as.matrix(cm22[,2:12])))
    )

call.mat.full1 <- call.mat1b %>%
  cbind(cmcr22) %>%
  as.numeric() %>%
  matrix(nrow = 18, ncol = 106)

call.mat.full <- call.mat.full1
call.mat.full[call.mat.full>0] <- 1

# make a matrix of methods for covariate (1 = roller, 2 = mulch, 3 = trap)
mulch <- matrix(c(rep(rep(0,18), 37), 
                  rep(rep(1,18), 32), 
                  rep(rep(0,18), 16), 
                  rep(rep(0,18), 10), 
                  rep(rep(0,18), 11)), 
                nrow = 18, ncol = 106)
trap <- matrix(c(rep(rep(0,18), 37), 
                 rep(rep(0,18), 32), 
                 rep(rep(1,18), 16), 
                  rep(rep(0,18), 10), 
                  rep(rep(0,18), 11)), 
                nrow = 18, ncol = 106)
roll22 <- matrix(c(rep(rep(0,18), 37), 
                 rep(rep(0,18), 32), 
                 rep(rep(0,18), 16), 
                  rep(rep(1,18), 10), 
                  rep(rep(0,18), 11)), 
                nrow = 18, ncol = 106)
mulch22 <- matrix(c(rep(rep(0,18), 37), 
                 rep(rep(0,18), 32), 
                 rep(rep(0,18), 16), 
                  rep(rep(0,18), 10), 
                  rep(rep(1,18), 11)), 
                nrow = 18, ncol = 106)

(z.trap = apply(call.mat.full, 1, max, na.rm = T))

# Bundle and summarize data set with traps
jags.data.traps <- list(
  y = call.mat.full,
  z = ifelse(z.trap > 0, 1, NA),
  n.sites = nrow(call.mat.full),
  n.samps = ncol(call.mat.full),
  mulch = mulch,
  trap = trap,
  roll22 = roll22,
  mulch22 = mulch22
)
```


# Including traps

# Define visit-level occupancy model in BUGS language
Can apply to either trap, roll, or mulch detection/non-detection data.
```{r}
sink("scripts/crb_trap_eDNA.txt")
cat("
model {

# Priors
mean.psi ~ dunif(0, 1)        # Occupancy intercept on prob. scale
gamma0 <- logit(mean.psi)      #   same on logit scale

mean.p ~ dunif(0, 1)          # Detection intercept on prob. scale
alpha0 <- logit(mean.p)       #   same on logit scale
alpha.mulch ~ dnorm(0, 0.1)   # Covariates on logit(detection)
alpha.trap ~ dnorm(0, 0.1)   # Covariates on logit(detection)
alpha.roll22 ~ dnorm(0, 0.1)   # Covariates on logit(detection)
alpha.mulch22 ~ dnorm(0, 0.1)   # Covariates on logit(detection)

# Likelihood
for (i in 1:n.sites) {
  z[i] ~ dbern(psi[i])
  logit(psi[i]) <- gamma0
  
   for (j in 1:n.samps) {
      y[i,j] ~ dbern(z[i] * p[i,j])
      logit(p[i,j]) <- alpha0 + alpha.mulch * mulch[i,j] +
                       alpha.trap * trap[i,j] +
                       alpha.roll22 * roll22[i,j] +
                       alpha.mulch22 * mulch22[i,j]
   }
}

# Derived quantities
# site-level occupancy for different densities
logit(psi.all) <- gamma0

# detection probability
logit(p.roll) <- alpha0
logit(p.mulch) <- alpha0 + alpha.mulch
logit(p.trap) <- alpha0 + alpha.trap
logit(p.roll22) <- alpha0 + alpha.roll22
logit(p.mulch22) <- alpha0 + alpha.mulch22
p.traproll.20 <- (1 - (1 - p.trap)*(1 - p.roll)^20)
p.traproll22.20 <- (1 - (1 - p.trap)*(1 - p.roll22)^20)
p.trapmulch.20 <- (1 - (1 - p.trap)*(1 - p.mulch)^20)
p.trapmulch22.20 <- (1 - (1 - p.trap)*(1 - p.mulch22)^20)
p.roll.20 <- (1 - (1 - p.roll)^20)
p.mulch.20 <- (1 - (1 - p.mulch)^20)
p.roll22.20 <- (1 - (1 - p.roll22)^20)
p.mulch22.20 <- (1 - (1 - p.mulch22)^20)
p.traproll.10 <- (1 - (1 - p.trap)*(1 - p.roll)^10)
p.traproll22.10 <- (1 - (1 - p.trap)*(1 - p.roll22)^10)
p.trapmulch.10 <- (1 - (1 - p.trap)*(1 - p.mulch)^10)
p.trapmulch22.10 <- (1 - (1 - p.trap)*(1 - p.mulch22)^10)
p.roll.10 <- (1 - (1 - p.roll)^10)
p.mulch.10 <- (1 - (1 - p.mulch)^10)
p.roll22.10 <- (1 - (1 - p.roll22)^10)
p.mulch22.10 <- (1 - (1 - p.mulch22)^10)

# # Cumulative sample-level detection probability for samples within an occupied site
# for(i in 1:150){
# p_tree_n_roll[i] <- (1 - (1 - p.roll)^i)
# p_tree_n_mulch[i] <- (1 - (1 - p.mulch)^i)
# p_tree_n_trap[i] <- (1 - (1 - p.trap)^i)
# p_tree_n_both[i] <- (1 - (1 - p_tree_n_roll[i])*(1 - p_tree_n_trap[i])^25)
# }

}

",fill=TRUE)
sink()

```
# Run Visual occupany model in JAGS
```{r}
# Initial values
inits <- function() list(int.psi = runif(1), 
                         int.p = runif(1), 
                         alpha.mulch = rnorm(1,0,1),
                         alpha.trap = rnorm(1,0,1),
                         alpha.roll22 = rnorm(1,0,1),
                         alpha.mulch22 = rnorm(1,0,1)
                         )

# Parameters monitored
params <- c("gamma0", 
            "alpha0", "alpha.mulch", "alpha.trap",
            "psi.all",
            "p.traproll.20", "p.traproll22.20",
            "p.trapmulch.20", "p.trapmulch22.20",             
            "p.traproll.10", "p.traproll22.10",
            "p.trapmulch.10", "p.trapmulch22.10", 
            "p.trap", 
            "p.roll.20", "p.mulch.20",
            "p.roll22.20", "p.mulch22.20",
            "p.roll.10", "p.mulch.10",
            "p.roll22.10", "p.mulch22.10",
            "p.roll", "p.roll22", "p.mulch", "p.mulch22")

#####################################
#### Run jags model
#####################################
crb_trap <- jagsUI::jags(data = jags.data.traps,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_trap_eDNA.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 2000,
                         n.iter = 50000,
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# saveRDS(crb_trap, "output/crb_roll_jags_mod_trap.rds")
crb_trap <- readRDS("output/crb_roll_jags_mod_trap.rds")

# Examine model output
crb_trap
plot(crb_trap)
# Examine traceplots
# jagsUI::traceplot(crb_roll)

```
# plot dp of trap and of trap+eDNA
```{r}

trap.p <- crb_trap$sims.list$p.trap
traproll.20.p <- crb_trap$sims.list$p.traproll.20
traproll22.20.p <- crb_trap$sims.list$p.traproll22.20



```
# Graphing detection probability of trap and "trap + roller eDNA"
```{r}

# format posterior data for roller
crb_plot = data.frame(posterior = c(crb_trap$sims.list$p.trap,
                         crb_trap$sims.list$p.traproll.10,
                         crb_trap$sims.list$p.traproll22.10
                         ),
           method = c(rep("Trap only (60 d)", 14400), 
                      rep("Trap + 10 eDNA samples\n(rainy season)", 14400),
                      rep("Trap + 10 eDNA samples\n(dry season)", 14400)),
           sub = "Roller"
           )

# format posterior data for mulch
crb_plot.m = data.frame(posterior = c(crb_trap$sims.list$p.trap,
                         crb_trap$sims.list$p.trapmulch.10,
                         crb_trap$sims.list$p.trapmulch22.10
                         ),
           method = c(rep("Trap only (60 d)", 14400), 
                      rep("Trap + 10 eDNA samples\n(rainy season)", 14400),
                      rep("Trap + 10 eDNA samples\n(dry season)", 14400)),
           sub = "Mulch"
           )
            

# summarize roller posteriors for plotting medians and 95% CI
crb_post_sum.r = aggregate(
  crb_plot$posterior,
  list(
    crb_plot$method
  ),
  median
) %>%
  bind_cols(ll = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$method
    ),
    FUN = 'quantile',
    probs = c(0.025)
  )$x) %>%
  bind_cols(ul = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$method
    ),
    FUN = 'quantile',
    probs = c(0.975)
  )$x) %>%
  bind_cols(ll10 = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$method
    ),
    FUN = 'quantile',
    probs = c(0.1)
  )$x) %>%
  bind_cols(ul90 = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$method
    ),
    FUN = 'quantile',
    probs = c(0.9)
  )$x) %>%
  rename(
    method = Group.1,
    med = x
  ) %>%
  mutate(sub = "Roller")

# summarize mulch posteriors for plotting medians and 95% CI
crb_post_sum.m = aggregate(
  crb_plot.m$posterior,
  list(
    crb_plot.m$method
  ),
  median
) %>%
  bind_cols(ll = aggregate(
    crb_plot.m$posterior,
    list(
      crb_plot.m$method
    ),
    FUN = 'quantile',
    probs = c(0.025)
  )$x) %>%
  bind_cols(ul = aggregate(
    crb_plot.m$posterior,
    list(
      crb_plot.m$method
    ),
    FUN = 'quantile',
    probs = c(0.975)
  )$x) %>%
  bind_cols(ll10 = aggregate(
    crb_plot.m$posterior,
    list(
      crb_plot.m$method
    ),
    FUN = 'quantile',
    probs = c(0.1)
  )$x) %>%
  bind_cols(ul90 = aggregate(
    crb_plot.m$posterior,
    list(
      crb_plot.m$method
    ),
    FUN = 'quantile',
    probs = c(0.9)
  )$x) %>%
  rename(
    method = Group.1,
    med = x
  ) %>%
  mutate(sub = "Mulch")

# combine

crb_post_sum <- bind_rows(crb_post_sum.r, crb_post_sum.m)

# make the plot

ggplot() +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll, xmax = ul,
                                          y = method,
                             color = method), width = 0, size = 0.75) +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll10, xmax = ul90,
                                          y = method,
                             color = method), width = 0, size = 1.7) +
  geom_point(data= crb_post_sum, aes(x = med, y = method,
                             color = method), size = 4) +
  scale_fill_manual(values = c("darkblue", "skyblue", "olivedrab")) +
  scale_color_manual(values = c("darkblue", "skyblue", "olivedrab")) +
  scale_x_continuous(limits = c(0.5,1)) +
  facet_wrap(~sub) +
  theme_bw() +
  # ggridges::theme_ridges() +
  theme(text = element_text(size = 14),
        axis.text.y = element_text(size = 15),
        strip.text = element_text(size = 14, vjust=0.5), 
        strip.background = element_rect(fill = "transparent",
                                        color = NA),
        axis.title.x = element_text(hjust = 0.5),
        panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA)) +
  labs(x = "Detection probability\nat infested site", y = "") +
  guides(fill = "none", color = "none")

 ggsave("figures/crb_trap.roll.mulch_dp.jpg",
        dpi = 600, width = 6, height = 4)
```
# Graphing detection probability of trap and "trap + roller eDNA" (20 samples)
```{r}

# format posterior data for roller
crb_plot = data.frame(posterior = c(crb_trap$sims.list$p.trap,
                         crb_trap$sims.list$p.traproll.20,
                         crb_trap$sims.list$p.traproll22.20
                         ),
           method = c(rep("Trap only (60 d)", 14400), 
                      rep("Trap + 20 eDNA samples\n(rainy season)", 14400),
                      rep("Trap + 20 eDNA samples\n(dry season)", 14400)),
           sub = "Roller"
           )

# format posterior data for mulch
crb_plot.m = data.frame(posterior = c(crb_trap$sims.list$p.trap,
                         crb_trap$sims.list$p.trapmulch.20,
                         crb_trap$sims.list$p.trapmulch22.20
                         ),
           method = c(rep("Trap only (60 d)", 14400), 
                      rep("Trap + 20 eDNA samples\n(rainy season)", 14400),
                      rep("Trap + 20 eDNA samples\n(dry season)", 14400)),
           sub = "Mulch"
           )
            

# summarize roller posteriors for plotting medians and 95% CI
crb_post_sum.r = aggregate(
  crb_plot$posterior,
  list(
    crb_plot$method
  ),
  median
) %>%
  bind_cols(ll = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$method
    ),
    FUN = 'quantile',
    probs = c(0.025)
  )$x) %>%
  bind_cols(ul = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$method
    ),
    FUN = 'quantile',
    probs = c(0.975)
  )$x) %>%
  bind_cols(ll10 = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$method
    ),
    FUN = 'quantile',
    probs = c(0.1)
  )$x) %>%
  bind_cols(ul90 = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$method
    ),
    FUN = 'quantile',
    probs = c(0.9)
  )$x) %>%
  rename(
    method = Group.1,
    med = x
  ) %>%
  mutate(sub = "Roller")

# summarize mulch posteriors for plotting medians and 95% CI
crb_post_sum.m = aggregate(
  crb_plot.m$posterior,
  list(
    crb_plot.m$method
  ),
  median
) %>%
  bind_cols(ll = aggregate(
    crb_plot.m$posterior,
    list(
      crb_plot.m$method
    ),
    FUN = 'quantile',
    probs = c(0.025)
  )$x) %>%
  bind_cols(ul = aggregate(
    crb_plot.m$posterior,
    list(
      crb_plot.m$method
    ),
    FUN = 'quantile',
    probs = c(0.975)
  )$x) %>%
  bind_cols(ll10 = aggregate(
    crb_plot.m$posterior,
    list(
      crb_plot.m$method
    ),
    FUN = 'quantile',
    probs = c(0.1)
  )$x) %>%
  bind_cols(ul90 = aggregate(
    crb_plot.m$posterior,
    list(
      crb_plot.m$method
    ),
    FUN = 'quantile',
    probs = c(0.9)
  )$x) %>%
  rename(
    method = Group.1,
    med = x
  ) %>%
  mutate(sub = "Mulch")

# combine

crb_post_sum <- bind_rows(crb_post_sum.r, crb_post_sum.m)

# make the plot

ggplot() +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll, xmax = ul,
                                          y = method,
                             color = method), width = 0, size = 0.75) +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll10, xmax = ul90,
                                          y = method,
                             color = method), width = 0, size = 1.7) +
  geom_point(data= crb_post_sum, aes(x = med, y = method,
                             color = method), size = 4) +
  scale_fill_manual(values = c("darkblue", "skyblue", "olivedrab")) +
  scale_color_manual(values = c("darkblue", "skyblue", "olivedrab")) +
  scale_x_continuous(limits = c(0.5,1)) +
  facet_wrap(~sub) +
  theme_bw() +
  # ggridges::theme_ridges() +
  theme(text = element_text(size = 14),
        axis.text.y = element_text(size = 15),
        strip.text = element_text(size = 14, vjust=0.5), 
        strip.background = element_rect(fill = "transparent",
                                        color = NA),
        axis.title.x = element_text(hjust = 0.5),
        panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA)) +
  labs(x = "Detection probability\nat infested site", y = "") +
  guides(fill = "none", color = "none")

 ggsave("figures/crb_trap.roll.mulch_dp_20samps.jpg",
        dpi = 600, width = 6, height = 4)
```
# Same but without mulch for presentation
```{r}

# format posterior data for roller
crb_plot.10 = data.frame(posterior = c(crb_trap$sims.list$p.trap,
                         crb_trap$sims.list$p.traproll.10,
                         crb_trap$sims.list$p.traproll22.10
                         ),
           method = c(rep("Trap only (60 d)", 14400), 
                      rep("Trap + eDNA\n(rainy season)", 14400),
                      rep("Trap + eDNA\n(dry season)", 14400)),
           sub = "10 samples"
           )

# format posterior data for mulch
crb_plot.20 = data.frame(posterior = c(crb_trap$sims.list$p.trap,
                         crb_trap$sims.list$p.traproll.20,
                         crb_trap$sims.list$p.traproll22.20
                         ),
           method = c(rep("Trap only (60 d)", 14400), 
                      rep("Trap + eDNA\n(rainy season)", 14400),
                      rep("Trap + eDNA\n(dry season)", 14400)),
           sub = "20 samples"
           )
            

# summarize roller (10 samples) posteriors for plotting medians and 95% CI
crb_post_sum.10 = aggregate(
  crb_plot.10$posterior,
  list(
    crb_plot.10$method
  ),
  median
) %>%
  bind_cols(ll = aggregate(
    crb_plot.10$posterior,
    list(
      crb_plot.10$method
    ),
    FUN = 'quantile',
    probs = c(0.025)
  )$x) %>%
  bind_cols(ul = aggregate(
    crb_plot.10$posterior,
    list(
      crb_plot.10$method
    ),
    FUN = 'quantile',
    probs = c(0.975)
  )$x) %>%
  bind_cols(ll10 = aggregate(
    crb_plot.10$posterior,
    list(
      crb_plot.10$method
    ),
    FUN = 'quantile',
    probs = c(0.1)
  )$x) %>%
  bind_cols(ul90 = aggregate(
    crb_plot.10$posterior,
    list(
      crb_plot.10$method
    ),
    FUN = 'quantile',
    probs = c(0.9)
  )$x) %>%
  rename(
    method = Group.1,
    med = x
  ) %>%
  mutate(sub = "10 samples")

# summarize roller (20 samples) posteriors for plotting medians and 95% CI
crb_post_sum.20 = aggregate(
  crb_plot.20$posterior,
  list(
    crb_plot.20$method
  ),
  median
) %>%
  bind_cols(ll = aggregate(
    crb_plot.20$posterior,
    list(
      crb_plot.20$method
    ),
    FUN = 'quantile',
    probs = c(0.025)
  )$x) %>%
  bind_cols(ul = aggregate(
    crb_plot.20$posterior,
    list(
      crb_plot.20$method
    ),
    FUN = 'quantile',
    probs = c(0.975)
  )$x) %>%
  bind_cols(ll10 = aggregate(
    crb_plot.20$posterior,
    list(
      crb_plot.20$method
    ),
    FUN = 'quantile',
    probs = c(0.1)
  )$x) %>%
  bind_cols(ul90 = aggregate(
    crb_plot.20$posterior,
    list(
      crb_plot.20$method
    ),
    FUN = 'quantile',
    probs = c(0.9)
  )$x) %>%
  rename(
    method = Group.1,
    med = x
  ) %>%
  mutate(sub = "20 samples")

# combine

crb_post_sum <- bind_rows(crb_post_sum.10, crb_post_sum.20)

# make the plot

ggplot() +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll, xmax = ul,
                                          y = method,
                             color = method), width = 0, size = 0.75) +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll10, xmax = ul90,
                                          y = method,
                             color = method), width = 0, size = 1.7) +
  geom_point(data= crb_post_sum, aes(x = med, y = method,
                             color = method), size = 4) +
  scale_fill_manual(values = c("darkblue", "skyblue", "olivedrab")) +
  scale_color_manual(values = c("darkblue", "skyblue", "olivedrab")) +
  scale_x_continuous(limits = c(0.5,1)) +
  facet_wrap(~sub) +
  theme_bw() +
  # ggridges::theme_ridges() +
  theme(text = element_text(size = 14),
        axis.text.y = element_text(size = 15),
        strip.text = element_text(size = 14, vjust=0.5), 
        strip.background = element_rect(fill = "transparent",
                                        color = NA),
        axis.title.x = element_text(hjust = 0.5),
        panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA)) +
  labs(x = "Detection probability\nat infested site", y = "") +
  guides(fill = "none", color = "none")

 ggsave("figures/crb_trap.roll_dp_10_and_20_samps.jpg",
        dpi = 600, width = 6, height = 4)
```








# Define visit-level occupancy model in BUGS language
Can apply to either trap, roll, or mulch detection/non-detection data.
```{r}
sink("scripts/crb_occupancy.txt")
cat("
model {

# Priors
mean.psi ~ dunif(0, 1)        # Occupancy intercept on prob. scale
gamma0 <- logit(mean.psi)      #   same on logit scale
# gamma.mdens ~ dnorm(0, 0.1)   # Covariates on logit(occupancy)
gamma.hdens ~ dnorm(0, 0.1)   # Covariates on logit(occupancy)

mean.p ~ dunif(0, 1)          # Detection intercept on prob. scale
alpha0 <- logit(mean.p)       #   same on logit scale
# alpha.mdens ~ dnorm(0, 0.1)   # Covariates on logit(detection)
alpha.hdens ~ dnorm(0, 0.1)   # Covariates on logit(detection)

# Likelihood
for (i in 1:n.sites) {
  z[i] ~ dbern(psi[i])
  logit(psi[i]) <- gamma0 + #gamma.mdens * mdens[i,1,1] +
                   gamma.hdens * hdens[i,1,1]
   for (j in 1:n.trees) {
      y[i,j] ~ dbern(z[i] * p[i,j])
      logit(p[i,j]) <- alpha0 + #alpha.mdens * mdens[i,j,1] +
                       alpha.hdens * hdens[i,j,1]
   }
}

# Derived quantities
# site-level occupancy for different densities
logit(psi.low) <- gamma0
# logit(psi.med) <- gamma0 + gamma.mdens
logit(psi.high) <- gamma0 + gamma.hdens

# detection probability
logit(p.low) <- alpha0
# logit(p.med) <- alpha0 + alpha.mdens
logit(p.high) <- alpha0 + alpha.hdens

# Cumulative board-level detection probability for 1-37 trees/site
for(i in 1:150){
p_tree_n_low[i] <- (1 - (1 - p.low)^i)
# p_tree_n_med[i] <- (1 - (1 - p.med)^i)
p_tree_n_high[i] <- (1 - (1 - p.high)^i)
}

# trees/site required to reach 95% certainty of detecting skinks within occupied areas
n_low <- log(20) / (-log(1 - p.low))
# n_med <- log(20) / (-log(1 - p.med))
n_high <- log(20) / (-log(1 - p.high))

}

",fill=TRUE)
sink()

```
# Run Visual occupany model in JAGS
```{r}
# Initial values
inits <- function() list(int.psi = runif(1), 
                         int.p = runif(1), 
                         gamma.mdens = rnorm(1, 0, 1),
                         alpha.mdens = rnorm(1,0,1),
                         gamma.hdens = rnorm(1, 0, 1),
                         alpha.hdens = rnorm(1,0,1))

# Parameters monitored
params <- c("gamma0", "gamma.mdens", "gamma.hdens",
            "alpha0", "alpha.mdens", "alpha.hdens",
            "psi.low", "psi.med",
            "psi.high", 
            "p.low", "p.med",
            "p.high",
            "p_tree_n_low", "p_tree_n_med", "p_tree_n_high",
            "n_low", "n_med", "n_high")

#####################################
#### Run jags model
#####################################
crb_roll <- jagsUI::jags(data = jags.data.roll,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_occupancy.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 10000,
                         n.iter = 160000,
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# saveRDS(crb_roll, "output/crb_roll_jags_mod_dens_hl.rds")
crb_roll <- readRDS("output/crb_roll_jags_mod_dens_hl.rds")

# Examine model output
crb_roll

# Examine traceplots
# jagsUI::traceplot(crb_roll)

```
# Run "visual + roller eDNA" occupany model in JAGS
note: it's the identical model to the visual model
```{r}
# # Initial values
# inits <- function() list(int.psi = runif(1), 
#                          int.p = runif(1), 
#                          gamma.season = rnorm(1, 0, 1),
#                          alpha.season = rnorm(1,0,1),
#                          gamma.material = rnorm(1, 0, 1),
#                          alpha.material = rnorm(1,0,1))
# 
# # Parameters monitored
# params <- c("gamma0", "gamma.season", "gamma.material",
#             "alpha0", "alpha.season", "alpha.material",
#             "psi.boards.fall.wood", "psi.boards.spring.wood",
#             "psi.boards.fall.metal", "psi.boards.spring.metal",
#             "p.fall.wood", "p.spring.wood",
#             "p.fall.metal", "p.spring.metal",
#             "p_board_n_spring", "p_board_n_fall",
#             "n_spring", "n_fall")
# 
# #####################################
# #### Run jags model
# #####################################
# skink_visroll <- jagsUI::jags(data = skink.jags.data.visroll,
#                          inits = inits,
#                          parameters.to.save = params,
#                          model.file = "scripts/skink_occupancy.txt",
#                          n.chains = 3,
#                          n.adapt = NULL,
#                          n.burnin = 10000,
#                          n.iter = 160000, 
#                          n.thin = 10,
#                          parallel = T,
#                          verbose = TRUE,
#                          modules = NULL)
# 
# # saveRDS(skink_visroll, "output/skink_visroll_jags_mod_material.rds")
# skink_visroll <- readRDS("output/skink_visroll_jags_mod_material.rds")
# 
# # Examine model output
# # skink_visroll
# 
# # Examine traceplots
# # jagsUI::traceplot(skink_visroll)

```
# Graphing detection probability 
```{r}


crb_plot = data.frame(posterior = c(crb_roll$sims.list$p.low,
                         crb_roll$sims.list$p.high
                         ),
           Density = c(rep("Low/med. density", 45000), rep("High density", 45000))
           )
            

# summarize posteriors for plotting medians and 95% CI
crb_post_sum = aggregate(
  crb_plot$posterior,
  list(
    crb_plot$Density
  ),
  median
) %>%
  bind_cols(ll = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$Density
    ),
    FUN = 'quantile',
    probs = c(0.025)
  )$x) %>%
  bind_cols(ul = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$Density
    ),
    FUN = 'quantile',
    probs = c(0.975)
  )$x) %>%
  bind_cols(ll10 = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$Density
    ),
    FUN = 'quantile',
    probs = c(0.1)
  )$x) %>%
  bind_cols(ul90 = aggregate(
    crb_plot$posterior,
    list(
      crb_plot$Density
    ),
    FUN = 'quantile',
    probs = c(0.9)
  )$x) %>%
  rename(
    Density = Group.1,
    med = x
  ) 

crb_plot %>%
  ggplot() +
  ggridges::stat_density_ridges(aes(x = posterior, 
                                     y = Density, 
                                     fill = Density),
                                     quantiles = 2,
                                alpha = 0.75, scale = 1.25) +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll, xmax = ul, 
                                          y = c(0.9,1.9),
                             color = Density), width = 0, size = 0.5) +
  geom_errorbar(data= crb_post_sum, aes(xmin = ll10, xmax = ul90, 
                                          y = c(0.9,1.9),
                             color = Density), width = 0, size = 1) +
  geom_point(data= crb_post_sum, aes(x = med, y = c(0.9,1.9),
                             color = Density), size = 3) +  
  scale_fill_manual(values = c("darkblue", "skyblue")) +
  scale_color_manual(values = c("darkblue", "skyblue")) +
  scale_x_continuous(limits = c(0,0.6)) +
  # facet_wrap(~Density) +
  theme_bw() +
  # ggridges::theme_ridges() +
  theme(text = element_text(size = 14),
        axis.text.y = element_text(size = 15),
        strip.text = element_text(size = 14, vjust=0.5), # vjust=0.9 theme_ridges
        strip.background = element_rect(fill = "transparent",
                                        color = NA),
        axis.title.x = element_text(hjust = 0.5),
        panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA)) +
  labs(x = "Per-sample eDNA detection probability\nat infested site", y = "") +
  coord_cartesian(clip = "off") +
  scale_y_discrete(expand = expand_scale(add = c(.5, 1.5))) +
  guides(fill = "none", color = "none")

 ggsave("figures/crb_roll_detection_probability.jpg",
        dpi = 600, width = 6, height = 4)
```

# Posterior summary statistics for visual-only and visual plus roller eDNA
```{r}
# view point estimates and 95% CI
crb_post_sum

# save table as HTML files
crb_table <- crb_post_sum %>%
  select(1:4) %>%
  mutate(med = med*100,
         ll = ll*100,
         ul = ul*100) %>%
 kableExtra::kbl(caption = "", digits = 1) %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria")

crb_table

# save the table to HTML file
kableExtra::save_kable(crb_table,
           "figures/dp_table.html")

%>%
  cat(., file = "figures/dp_table.html")


```


# Plot cumulative detection probability vs. number of samples
```{r}

# Format data and create figure
# first load the sum_posts function 
sum_posts = function(x, density = NULL){
  sum_posts_list = aggregate(x, by = list(rep("A", nrow(x))), FUN = function(x) quantile(x, c(0.025, 0.10, 0.5, 0.90, 0.975))) %>%
  select(-Group.1) %>%
  c()

sum_posts_df = do.call("rbind", sum_posts_list) %>% 
  as.data.frame() %>%
  rename(q2.5 = 1, q10 = 2, q50 = 3, q90 = 4, q97.5 = 5) %>%
  mutate(n = 1:length(sum_posts_list),
         Density = density)

return(sum_posts_df)
}

cplot_all <- rbind.data.frame(
sum_posts(crb_roll$sims.list$p_tree_n_low, density = "Low/med. density"),
sum_posts(crb_roll$sims.list$p_tree_n_high, density = "High density")
)

cplot_all %>%
  # filter(n < 65) %>%
  ggplot() +
  geom_abline(slope = 0, intercept = 0.95, color = "darkgray", size=1, linetype = 2) +
  geom_ribbon(aes(x = n, ymin = q2.5, ymax = q97.5, fill = Density),
              alpha = 0.5, color = "transparent") +
  # geom_errorbar(aes(x = n, ymin = q2.5, ymax = q97.5, color = Method),
  #             width = 0, size = 0.5) +  
  # geom_errorbar(aes(x = n, ymin = q10, ymax = q90, color = Method),
  #             width = 0, size = 1) +
  scale_fill_manual(values = c("darkgray", "darkgray")) +
  geom_line(aes(x = n, y = q50, color = Density, linetype = Density), size = 1) +
  # geom_point(aes(x = n, y = q50, color = Density, 
  #                shape = Density), size = 2,
  #            fill = "white") +
  scale_shape_manual(values = c(16,21)) +
  scale_color_manual(values = c("black", "black")) +
  # facet_wrap(~season) +
  theme_bw() +
  theme(axis.text = element_text(size = 15),
        axis.title = element_text(size = 15),
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12)) +
  labs(y = "Probability of \u2265 1 detection", 
       x = "Number of trees sampled\nat infested site") +
  theme(strip.text = element_text(
    size = 14,
    colour = "black",
    angle = 0
    ), 
    strip.background = element_rect(fill = "transparent",
                                        color = NA))

# ggsave("figures/crb_cumulative_eDNA_detection.jpg", width = 6, height = 4, dpi = 600)
```



# Define Bayesian qPCR-replicate-based multilevel occ. mod. in JAGS
# version with low vs. high/medium density and roller vs. mulch
JAGS code modified from Kéry & Royle (2015, pp. 606-607).
model from Dorazio & Erickson 2018

Kéry, M., & Royle, J. A. (2015). Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS: Volume 1: Prelude and Static Models. London: Academic Press. 
```{r}
sink("scripts/crb_rollermulch_eDNA_multilevel.txt")
cat("
model {

# Priors and model for params
int.psi ~ dunif(0,1)         # Intercept of occupancy probability
gamma0 <- logit(int.psi)       # same on logit scale
gamma.hmdens ~ dnorm(0, 0.1)   # season covariate on logit(site-level occupancy)

int.theta ~ dunif(0,1)       # Intercept plot-level occupancy probability
beta0 <- logit(int.theta)      # same on logit scale
beta.hmdens ~ dnorm(0, 0.1)   # covariate on logit(tree-level occupancy)
beta.roller.mulch ~ dnorm(0, 0.1) # covariate on logit(tree/sample-level occupancy)

int.p ~ dunif(0,1)           # Intercept detection probability
alpha0 <- logit(int.p)         # same on logit scale
alpha.hmdens ~ dnorm(0, 0.1)   # covariate on logit(detection given DNA capture)
alpha.roller.mulch ~ dnorm(0, 0.1) # covariate on logit(detection given DNA capture)

# Likelihood
for (i in 1:n.sites){
   # Occurrence at board i
   z[i] ~ dbern(psi[i])
   logit(psi[i]) <- gamma0 + gamma.hmdens * hmdens[i,1,1]
   for (j in 1:n.trees){
      # eDNA capture probability (availability) in visit j
      a[i,j] ~ dbern(z[i] * theta[i,j])
       logit(theta[i,j]) <- beta0 + beta.hmdens * hmdens[i,j,1] +
                            beta.roller.mulch * roller.mulch[i,j,1]
      for (k in 1:n.PCRrep){
         # detection process for PCR replicate k
         y[i,j,k] ~ dbern(a[i,j] * p[i,j,k])
         logit(p[i,j,k]) <- alpha0 + alpha.hmdens * hmdens[i,j,k] +
                            alpha.roller.mulch * roller.mulch[i,j,k]
      }
   }
 }

# Derived quantities
# site-level occupancy by density
logit(psi.low) <- gamma0
logit(psi.high) <- gamma0 + gamma.hmdens

# Theta or eDNA capture probability
logit(theta.low.roll) <- beta0 + beta.roller.mulch
logit(theta.low.mulch) <- beta0
logit(theta.high.roll) <- beta0 + beta.hmdens + beta.roller.mulch
logit(theta.high.mulch) <- beta0 + beta.hmdens

# Detection probabity for an individual qPCR replicate
logit(p.low.roll) <- alpha0 + alpha.roller.mulch
logit(p.low.mulch) <- alpha0
logit(p.high.roll) <- alpha0 + alpha.hmdens + alpha.roller.mulch
logit(p.high.mulch) <- alpha0 + alpha.hmdens

# Equation for 'at least one hit' given presence in sample
for(i in 1:6){
p.eDNA_low.roll[i] <- (1-(1-p.low.roll)^i)
p.eDNA_low.mulch[i] <- (1-(1-p.low.mulch)^i)
p.eDNA_high.roll[i] <- (1-(1-p.high.roll)^i)
p.eDNA_high.mulch[i] <- (1-(1-p.high.mulch)^i)
}

# Equation for total detection = capture x probability of 'at least one hit'
for(i in 1:6){
p.eDNA_detect.low.roll[i] <- theta.low.roll * (1-(1-p.low.roll)^i)
p.eDNA_detect.low.mulch[i] <- theta.low.mulch * (1-(1-p.low.mulch)^i)
p.eDNA_detect.high.roll[i] <- theta.high.roll * (1-(1-p.high.roll)^i)
p.eDNA_detect.high.mulch[i] <- theta.high.mulch * (1-(1-p.high.mulch)^i)
}


}
",fill=TRUE)
sink()
```
# Run Bayesian qPCR-replicate-based multilevel occupancy model in JAGS
model from Dorazio & Errickson 2018 (code from Kery & Royle 2015)
```{r}
# Initial values
inits <- function() list(a = apply(y.both, c(1,2), max), 
                         # inits for availability (a)
                         # z = ifelse(z.both>1,as.numeric(1),as.numeric(NA)), # inits for presence (z)
                         int.psi = runif(1), 
                         int.theta = runif(1),
                         int.p = runif(1), 
                         gamma.hmdens = rnorm(1, 0, 1),
                         beta.hmdens = rnorm(1, 0, 1),
                         alpha.hmdens = rnorm(1,0, 1),
                         gamma.roller.mulch = rnorm(1, 0, 1),
                         beta.roller.mulch = rnorm(1, 0, 1),
                         alpha.roller.mulch = rnorm(1,0, 1))

# Parameters monitored
params <- c("gamma0", "gamma.hmdens", 
            "beta0", "beta.hmdens", "beta.roller.mulch",
            "alpha0", "alpha.hmdens", "alpha.roller.mulch",
            "psi.low", "psi.high",
            "theta.low.roll", "theta.low.mulch", 
            "theta.high.roll", "theta.high.mulch", 
            "p.low.roll", "p.low.mulch", 
            "p.high.roll", "p.high.mulch", 
            "p.eDNA_detect.low.roll", "p.eDNA_detect.low.mulch",
            "p.eDNA_detect.high.roll", "p.eDNA_detect.high.mulch",
            "p.eDNA_low.roll", "p.eDNA_low.mulch",
            "p.eDNA_high.roll", "p.eDNA_high.mulch")

#####################################
#### Run jags model
#####################################
crb_eDNApcr <- jagsUI::jags(data = jags.data.both.qPCR,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_rollermulch_eDNA_multilevel.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 20000,
                         n.iter = 120000, 
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# Examine model output
crb_eDNApcr
# saveRDS(skink_eDNA, "output/skink_visroll_jags_mod_materials.rds")
skink_eDNA <- readRDS("output/skink_eDNA_jags_mod_materials.rds")


# Examine traceplots
# jagsUI::traceplot(skink_eDNA)
```
# summarizing posteriors for multilevel roller eDNA JAGS model
qPCR-relplicate detection probability model (Dorazio & Erickson, 2018)
```{r}
# load the multilevel roller eDNA JAGS model
skink_eDNA <- readRDS("output/skink_eDNA_jags_mod_materials.rds")

# 1 tech rep
med_eDNA1 <- t(data.frame(skink_eDNA$q50))[26:29,1]
ll_eDNA1 <- t(data.frame(skink_eDNA$q2.5))[26:29,1]
ul_eDNA1 <- t(data.frame(skink_eDNA$q97.5))[26:29,1]
eDNA_preds1 <- cbind(med_eDNA1, ll_eDNA1, ul_eDNA1)*100

# 2 tech reps
med_eDNA2 <- t(data.frame(skink_eDNA$q50))[26:29,2]
ll_eDNA2 <- t(data.frame(skink_eDNA$q2.5))[26:29,2]
ul_eDNA2 <- t(data.frame(skink_eDNA$q97.5))[26:29,2]
eDNA_preds2 <- cbind(med_eDNA2, ll_eDNA2, ul_eDNA2)*100

# 3 tech reps
med_eDNA3 <- t(data.frame(skink_eDNA$q50))[26:29,3]
ll_eDNA3 <- t(data.frame(skink_eDNA$q2.5))[26:29,3]
ul_eDNA3 <- t(data.frame(skink_eDNA$q97.5))[26:29,3]
eDNA_preds3 <- cbind(med_eDNA3, ll_eDNA3, ul_eDNA3)*100

# 4 tech reps
med_eDNA4 <- t(data.frame(skink_eDNA$q50))[26:29,4]
ll_eDNA4 <- t(data.frame(skink_eDNA$q2.5))[26:29,4]
ul_eDNA4 <- t(data.frame(skink_eDNA$q97.5))[26:29,4]
eDNA_preds4 <- cbind(med_eDNA4, ll_eDNA4, ul_eDNA4)*100

# 5 tech reps
med_eDNA5 <- t(data.frame(skink_eDNA$q50))[26:29,5]
ll_eDNA5 <- t(data.frame(skink_eDNA$q2.5))[26:29,5]
ul_eDNA5 <- t(data.frame(skink_eDNA$q97.5))[26:29,5]
eDNA_preds5 <- cbind(med_eDNA5, ll_eDNA5, ul_eDNA5)*100

# 6 tech reps
med_eDNA6 <- t(data.frame(skink_eDNA$q50))[26:29,6]
ll_eDNA6 <- t(data.frame(skink_eDNA$q2.5))[26:29,6]
ul_eDNA6 <- t(data.frame(skink_eDNA$q97.5))[26:29,6]
eDNA_preds6 <- cbind(med_eDNA6, ll_eDNA6, ul_eDNA6)*100

cbind(eDNA_preds1, eDNA_preds2, eDNA_preds3, eDNA_preds4, eDNA_preds5, eDNA_preds6) %>%
  t() %>%
  as.data.frame() %>%
  knitr::kable(format = "html", digits = 1) %>%
  cat(., file = "tables/tableS3A.html")

```



# Define Bayesian qPCR-replicate-based multilevel occ. mod. in JAGS
# version with low vs. high/medium density and ROLLER ONLY
JAGS code modified from Kéry & Royle (2015, pp. 606-607).
model from Dorazio & Erickson 2018

Kéry, M., & Royle, J. A. (2015). Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS: Volume 1: Prelude and Static Models. London: Academic Press. 
```{r}
sink("scripts/crb_roller_eDNA_multilevel.txt")
cat("
model {

# Priors and model for params
int.psi ~ dunif(0,1)         # Intercept of occupancy probability
gamma0 <- logit(int.psi)       # same on logit scale
gamma.hmdens ~ dnorm(0, 0.1)   # season covariate on logit(site-level occupancy)

int.theta ~ dunif(0,1)       # Intercept plot-level occupancy probability
beta0 <- logit(int.theta)      # same on logit scale
beta.hmdens ~ dnorm(0, 0.1)   # covariate on logit(tree-level occupancy)
# beta.roller.mulch ~ dnorm(0, 0.1) # covariate on logit(tree/sample-level occupancy)

int.p ~ dunif(0,1)           # Intercept detection probability
alpha0 <- logit(int.p)         # same on logit scale
alpha.hmdens ~ dnorm(0, 0.1)   # covariate on logit(detection given DNA capture)
# alpha.roller.mulch ~ dnorm(0, 0.1) # covariate on logit(detection given DNA capture)

# Likelihood
for (i in 1:n.sites){
   # Occurrence at board i
   # z[i] ~ dbern(psi[i])
   # logit(psi[i]) <- gamma0 + gamma.hmdens * hmdens[i,1,1]
   for (j in 1:n.trees){
      # eDNA capture probability (availability) in visit j
      a[i,j] ~ dbern(z[i] * theta[i,j])
       logit(theta[i,j]) <- beta0 + beta.hmdens * hmdens[i,j,1]
      for (k in 1:n.PCRrep){
         # detection process for PCR replicate k
         y[i,j,k] ~ dbern(a[i,j] * p[i,j,k])
         logit(p[i,j,k]) <- alpha0 + alpha.hmdens * hmdens[i,j,k]
      }
   }
 }

# Derived quantities
# site-level occupancy by density
# logit(psi.low) <- gamma0
# logit(psi.high) <- gamma0 + gamma.hmdens

# Theta or eDNA capture probability
logit(theta.low.roll) <- beta0
logit(theta.high.roll) <- beta0 + beta.hmdens

# Detection probabity for an individual qPCR replicate
logit(p.low.roll) <- alpha0
logit(p.high.roll) <- alpha0 + alpha.hmdens

# Equation for 'at least one hit' given presence in sample
for(i in 1:8){
p.eDNA_low.roll[i] <- (1-(1-p.low.roll)^i)
p.eDNA_high.roll[i] <- (1-(1-p.high.roll)^i)
}

# Equation for total detection = capture x probability of 'at least one hit' w/ 8 tech reps
for(i in 1:100){
p.eDNA_detect.low.roll[i] <- 1-(1-(theta.low.roll * (1-(1-p.low.roll)^8)))^i
p.eDNA_detect.high.roll[i] <- 1-(1-(theta.high.roll * (1-(1-p.high.roll)^8)))^i
}


}
",fill=TRUE)
sink()
```
# Run Bayesian qPCR-replicate-based multilevel occupancy model in JAGS
model from Dorazio & Errickson 2018 (code from Kery & Royle 2015)
```{r}
# Initial values
inits <- function() list(a = apply(y.roll, c(1,2), max), 
                         # inits for availability (a)
                         # z = ifelse(z.both>1,as.numeric(1),as.numeric(NA)), # inits for presence (z)
                         int.psi = runif(1), 
                         int.theta = runif(1),
                         int.p = runif(1), 
                         gamma.hmdens = rnorm(1, 0, 1),
                         beta.hmdens = rnorm(1, 0, 1),
                         alpha.hmdens = rnorm(1,0, 1),
                         gamma.roller.mulch = rnorm(1, 0, 1),
                         beta.roller.mulch = rnorm(1, 0, 1),
                         alpha.roller.mulch = rnorm(1,0, 1))

# Parameters monitored
params <- c("gamma0", "gamma.hmdens", 
            "beta0", "beta.hmdens", "beta.roller.mulch",
            "alpha0", "alpha.hmdens", "alpha.roller.mulch",
            "psi.low", "psi.high",
            "theta.low.roll", "theta.low.mulch", 
            "theta.high.roll", "theta.high.mulch", 
            "p.low.roll", "p.low.mulch", 
            "p.high.roll", "p.high.mulch", 
            "p.eDNA_detect.low.roll", "p.eDNA_detect.low.mulch",
            "p.eDNA_detect.high.roll", "p.eDNA_detect.high.mulch",
            "p.eDNA_low.roll", "p.eDNA_low.mulch",
            "p.eDNA_high.roll", "p.eDNA_high.mulch")

#####################################
#### Run jags model
#####################################
# define hmdens as high density only (i.e., group low/med vs. high)
jags.data.roll.qPCR2 <- jags.data.roll.qPCR
jags.data.roll.qPCR2$hmdens <- jags.data.roll.qPCR$hdens
crb_eDNA <- jagsUI::jags(data = jags.data.roll.qPCR,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_roller_eDNA_multilevel.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 20000,
                         n.iter = 120000, 
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# Examine model output
crb_eDNA
# saveRDS(crb_eDNA, "output/crb_qPCR_roll_jags_mod_highmed_v_low_density_aug29.rds")


# Examine traceplots
# jagsUI::traceplot(skink_eDNA)
```
# summarizing posteriors for multilevel roller eDNA JAGS model
qPCR-relplicate detection probability model (Dorazio & Erickson, 2018)
```{r}
# load the multilevel roller eDNA JAGS model
# crb_eDNA <- readRDS("output/crb_qPCR_roll_jags_mod_highmed_v_low_density_aug29.rds")

# tech reps (low dens)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_low.roll)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_low.roll)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_low.roll)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_low.roll, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_low.roll, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high/med dens)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(techreps = c(1:8,1:8),
         dens = c(rep("Low density", 8), rep("High/med. density", 8)))

(techreps_plot <- df %>%
  ggplot() +
  geom_errorbar(aes(x = techreps, ymin = ll, ymax = ul, color = dens),
                position = position_dodge(width = 1),
                width = 0) +
  geom_errorbar(aes(x = techreps, ymin = ll10, ymax = ul90, color = dens),
                position = position_dodge(width = 1),
                width = 0, linewidth = 1) +
  geom_point(aes(x = techreps, y = med, color = dens),
                position = position_dodge(width = 1),
             size = 3) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "Technical replicates",
       y = "Detection prob. given eDNA capture\nwithin roller sample",
       color = "") +
  theme_bw() +
    guides(color = "none")
)

# num samples at 8 tech reps (low dens)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.low.roll)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.low.roll)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.low.roll)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.low.roll, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.low.roll, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high/med dens)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.high.roll)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.high.roll)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.high.roll)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df_samps <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(numsamps = c(1:100,1:100),
         dens = c(rep("Low density", 100), rep("High/med. density", 100)))

(samps_plot <- df_samps %>%
  ggplot() +
  geom_ribbon(aes(x = numsamps, ymin = ll, ymax = ul, fill = dens),
                position = position_dodge(width = 1),
              alpha = 0.5) +
  geom_ribbon(aes(x = numsamps, ymin = ll10, ymax = ul90, fill = dens),
                position = position_dodge(width = 1),
              alpha = 0.5) +
  geom_line(aes(x = numsamps, y = med, color = dens), linewidth = 1) +
  scale_fill_manual(values = c("olivedrab", "steelblue")) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "No. roller samples (at 8 tech. replicates)",
       y = "Cumulative detection probability\nat infested site (%)",
       fill = "",
       color = "") +
  theme_bw() +
  theme(text = element_text(size = 12))
)

library(patchwork)

techreps_plot + samps_plot

ggsave("figures/model_with_qPCRrep_highmed_vs_low.jpg", width = 9, height = 4, dpi = 400)
```







# Year 2022 vs. 2023 at high-density sites

# Define Bayesian qPCR-replicate-based multilevel occ. mod. in JAGS
# version with low vs. high density and ROLLER ONLY, 2022 vs. 2023
JAGS code modified from Kéry & Royle (2015, pp. 606-607).
model from Dorazio & Erickson 2018

Kéry, M., & Royle, J. A. (2015). Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS: Volume 1: Prelude and Static Models. London: Academic Press. 
```{r}
sink("scripts/crb_roller_eDNA_multilevel_year.txt")
cat("
model {

# Priors and model for params
int.psi ~ dunif(0,1)         # Intercept of occupancy probability
gamma0 <- logit(int.psi)       # same on logit scale

int.theta ~ dunif(0,1)       # Intercept plot-level occupancy probability
beta0 <- logit(int.theta)      # same on logit scale
beta.year ~ dnorm(0, 0.1)   # covariate on logit(tree-level occupancy)

int.p ~ dunif(0,1)           # Intercept detection probability
alpha0 <- logit(int.p)         # same on logit scale
alpha.year ~ dnorm(0, 0.1)   # covariate on logit(detection given DNA capture)

# Likelihood
for (i in 1:n.sites){
   # Occurrence at board i
   # z[i] ~ dbern(psi[i])
   # logit(psi[i]) <- gamma0
   for (j in 1:n.trees){
      # eDNA capture probability (availability) in visit j
      a[i,j] ~ dbern(z[i] * theta[i,j])
       logit(theta[i,j]) <- beta0 + beta.year * year[i,j,1]
      for (k in 1:n.PCRrep){
         # detection process for PCR replicate k
         y[i,j,k] ~ dbern(a[i,j] * p[i,j,k])
         logit(p[i,j,k]) <- alpha0 + alpha.year * year[i,j,k]
      }
   }
 }

# Derived quantities
# site-level occupancy by density
logit(psi.high) <- gamma0

# Theta or eDNA capture probability
logit(theta.high.roll22) <- beta0
logit(theta.high.roll23) <- beta0 + beta.year

# Detection probabity for an individual qPCR replicate
logit(p.high.roll22) <- alpha0
logit(p.high.roll23) <- alpha0 + alpha.year

# Equation for 'at least one hit' given presence in sample
for(i in 1:8){
p.eDNA_high.roll22[i] <- (1-(1-p.high.roll22)^i)
p.eDNA_high.roll23[i] <- (1-(1-p.high.roll23)^i)
}

# Equation for total detection = capture x probability of 'at least one hit' w/ 8 tech reps
for(i in 1:20){
p.eDNA_detect.high.roll22[i] <- 1-(1-(theta.high.roll22 * (1-(1-p.high.roll22)^8)))^i
p.eDNA_detect.high.roll23[i] <- 1-(1-(theta.high.roll23 * (1-(1-p.high.roll23)^8)))^i
}

# Equation for total DNA capture (probability of 'at least one' sample w/ DNA)
for(i in 1:20){
cumcapture22[i] <- 1-(1-theta.high.roll22)^i
cumcapture23[i] <- 1-(1-theta.high.roll23)^i
}

}
",fill=TRUE)
sink()
```
# Run Bayesian qPCR-replicate-based multilevel occupancy model in JAGS
model from Dorazio & Errickson 2018 (code from Kery & Royle 2015)
```{r}
# Initial values
inits <- function() list(a = apply(y.roll22high, c(1,2), max), 
                         # inits for availability (a)
                         # z = ifelse(z.both>1,as.numeric(1),as.numeric(NA)), # inits for presence (z)
                         int.psi = runif(1), 
                         int.theta = runif(1),
                         int.p = runif(1), 
                         gamma.hmdens = rnorm(1, 0, 1),
                         beta.hmdens = rnorm(1, 0, 1),
                         alpha.hmdens = rnorm(1,0, 1),
                         gamma.roller.mulch = rnorm(1, 0, 1),
                         beta.roller.mulch = rnorm(1, 0, 1),
                         alpha.roller.mulch = rnorm(1,0, 1))

# Parameters monitored
params <- c("gamma0", 
            "beta0", "beta.year", 
            "alpha0", "alpha.year", 
            "psi.low", "psi.high",
            "theta.high.roll22", 
            "theta.high.roll23", 
            "p.high.roll22", 
            "p.high.roll23", 
            "p.eDNA_detect.high.roll22", 
            "p.eDNA_detect.high.roll23", 
            "p.eDNA_high.roll22", 
            "p.eDNA_high.roll23",
            "cumcapture22", "cumcapture23")

#####################################
#### Run jags model
#####################################
crb_eDNA22high <- jagsUI::jags(data = jags.data.roll.qPCR.22high,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_roller_eDNA_multilevel_year.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 20000,
                         n.iter = 120000, 
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# Examine model output
crb_eDNA22high
# saveRDS(crb_eDNA22high, "output/crb_qPCR_roll_jags_mod_density_eDNA22high.rds")
# crb_eDNA <- readRDS("output/crb_qPCR_roll_jags_mod_density_eDNA22high.rds")


# Examine traceplots
# jagsUI::traceplot(skink_eDNA)
```
# summarizing posteriors for multilevel roller eDNA JAGS model
qPCR-relplicate detection probability model (Dorazio & Erickson, 2018)
```{r}
# load the multilevel roller eDNA JAGS model
# crb_eDNA <- readRDS("output/crb_qPCR_roll_jags_mod_density_eDNA22high.rds")
crb_eDNA <- crb_eDNA22high

# tech reps (high dens 2022)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll22)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll22)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll22)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll22, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll22, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high dens 2023)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll23)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll23)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll23)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll23, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll23, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(techreps = c(1:8,1:8),
         dens = c(rep("2022", 8), rep("2023", 8)))

(techreps_plot <- df %>%
  ggplot() +
  geom_errorbar(aes(x = techreps, ymin = ll, ymax = ul, color = dens),
                position = position_dodge(width = 1),
                width = 0) +
  geom_errorbar(aes(x = techreps, ymin = ll10, ymax = ul90, color = dens),
                position = position_dodge(width = 1),
                width = 0, linewidth = 1) +
  geom_point(aes(x = techreps, y = med, color = dens),
                position = position_dodge(width = 1),
             size = 3) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "Technical replicates",
       y = "Detection prob. given eDNA capture\nwithin sample (roller)",
       color = "") +
  theme_bw() +
    guides(color = "none")
)

# num samples at 8 tech reps (high dens 2022)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.high.roll22)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.high.roll22)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.high.roll22)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll22, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll22, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high dens 2023)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.high.roll23)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.high.roll23)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.high.roll23)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll23, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll23, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df_samps <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(numsamps = c(1:20,1:20),
         dens = c(rep("2022", 20), rep("2023", 20)))

(samps_plot <- df_samps %>%
    filter(numsamps < 21) %>%
  ggplot() +
  geom_ribbon(aes(x = numsamps, ymin = ll, ymax = ul, fill = dens),
                position = position_dodge(width = 1),
              alpha = 0.5) +
  # geom_ribbon(aes(x = numsamps, ymin = ll10, ymax = ul90, fill = dens),
  #               position = position_dodge(width = 1),
  #             alpha = 0.5) +
  geom_line(aes(x = numsamps, y = med, color = dens), linewidth = 1) +
  scale_fill_manual(values = c("olivedrab", "steelblue")) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  geom_hline(yintercept = 95, lty = 2, color = "darkgray") +
  labs(x = "No. roller samples (at 8 tech. replicates)",
       y = "Cumulative detection probability\nat infested site (%)",
       fill = "",
       color = "") +
  theme_bw() +
  theme(text = element_text(size = 12))
)

library(patchwork)

techreps_plot + samps_plot

ggsave("figures/model_with_qPCRrep_highdensityonly_2022_2023_roller.jpg", width = 9, height = 4, dpi = 400)
```
# AGAIN but version with THETA increasing (and switched order)
# summarizing posteriors for multilevel roller eDNA JAGS model
qPCR-relplicate detection probability model (Dorazio & Erickson, 2018)
```{r}
# load the multilevel roller eDNA JAGS model
crb_eDNA <- readRDS("output/crb_qPCR_roll_jags_mod_density_eDNA22high.rds")

# tech reps (high dens 2022)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll22)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll22)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll22)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll22, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll22, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high dens 2023)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll23)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll23)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll23)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll23, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll23, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(techreps = c(1:8,1:8),
         dens = c(rep("2022", 8), rep("2023", 8)))

(techreps_plot <- df %>%
  ggplot() +
  geom_errorbar(aes(x = techreps, ymin = ll, ymax = ul, color = dens),
                position = position_dodge(width = 1),
                width = 0) +
  geom_errorbar(aes(x = techreps, ymin = ll10, ymax = ul90, color = dens),
                position = position_dodge(width = 1),
                width = 0, linewidth = 1) +
  geom_point(aes(x = techreps, y = med, color = dens),
                position = position_dodge(width = 1),
             size = 3) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "Technical replicates",
       y = "Detection prob. given eDNA\ncapture within sample",
       color = "") +
  theme_bw()
)

# cumulative DNA capture probability with increasing number of samples (high dens 2022)
med_eDNA <- data.frame(crb_eDNA$q50$cumcapture22)
ll_eDNA <- data.frame(crb_eDNA$q2.5$cumcapture22)
ul_eDNA <- data.frame(crb_eDNA$q97.5$cumcapture22)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$cumcapture22, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$cumcapture22, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# cumulative DNA capture probability with increasing number of samples (high dens 2023)
med_eDNA <- data.frame(crb_eDNA$q50$cumcapture23)
ll_eDNA <- data.frame(crb_eDNA$q2.5$cumcapture23)
ul_eDNA <- data.frame(crb_eDNA$q97.5$cumcapture23)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$cumcapture23, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$cumcapture23, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df_samps <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(numsamps = c(1:20,1:20),
         dens = c(rep("2022", 20), rep("2023", 20)))

(samps_plot <- df_samps %>%
    filter(numsamps < 21) %>%
  ggplot() +
  geom_ribbon(aes(x = numsamps, ymin = ll, ymax = ul, fill = dens),
                position = position_dodge(width = 1),
              alpha = 0.5) +
  # geom_ribbon(aes(x = numsamps, ymin = ll10, ymax = ul90, fill = dens),
  #               position = position_dodge(width = 1),
  #             alpha = 0.5) +
  geom_line(aes(x = numsamps, y = med, color = dens), linewidth = 1) +
  scale_fill_manual(values = c("olivedrab", "steelblue")) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  geom_hline(yintercept = 95, lty = 2, color = "darkgray") +
  labs(x = "No. roller samples",
       y = "eDNA capture probability within\nsample at infested site (%)",
       fill = "",
       color = "") +
  theme_bw() +
  theme(text = element_text(size = 12)) +
    guides(fill = "none", color = "none")
)

library(patchwork)

samps_plot + techreps_plot

ggsave("figures/model_with_qPCRrep_highdensityonly_2022_2023_roller_updated.jpg", width = 9, height = 4, dpi = 400)
```


##### MULCH


# Run Bayesian qPCR-replicate-based multilevel occupancy model in JAGS
model from Dorazio & Errickson 2018 (code from Kery & Royle 2015)
```{r}
# Initial values
inits <- function() list(a = apply(y.mulch22high, c(1,2), max), 
                         # inits for availability (a)
                         # z = ifelse(z.both>1,as.numeric(1),as.numeric(NA)), # inits for presence (z)
                         int.psi = runif(1), 
                         int.theta = runif(1),
                         int.p = runif(1), 
                         gamma.hmdens = rnorm(1, 0, 1),
                         beta.hmdens = rnorm(1, 0, 1),
                         alpha.hmdens = rnorm(1,0, 1),
                         gamma.roller.mulch = rnorm(1, 0, 1),
                         beta.roller.mulch = rnorm(1, 0, 1),
                         alpha.roller.mulch = rnorm(1,0, 1))

# Parameters monitored
params <- c("gamma0", 
            "beta0", "beta.year", 
            "alpha0", "alpha.year", 
            "psi.low", "psi.high",
            "theta.high.roll22", 
            "theta.high.roll23", 
            "p.high.roll22", 
            "p.high.roll23", 
            "p.eDNA_detect.high.roll22", 
            "p.eDNA_detect.high.roll23", 
            "p.eDNA_high.roll22", 
            "p.eDNA_high.roll23")

#####################################
#### Run jags model
#####################################
crb_eDNA22high.mulch <- jagsUI::jags(data = jags.data.mulch.qPCR.22high,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/crb_roller_eDNA_multilevel_year.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 20000,
                         n.iter = 120000, 
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# Examine model output
crb_eDNA22high.mulch
# saveRDS(crb_eDNA, "output/crb_qPCR_roll_jags_mod_density.rds")
# crb_eDNA <- readRDS("output/crb_qPCR_roll_jags_mod_density.rds")


# Examine traceplots
# jagsUI::traceplot(skink_eDNA)
```
# summarizing posteriors for multilevel roller eDNA JAGS model
qPCR-relplicate detection probability model (Dorazio & Erickson, 2018)
```{r}
# load the multilevel roller eDNA JAGS model
# crb_eDNA <- readRDS("output/skink_eDNA_jags_mod_materials.rds")
crb_eDNA <- crb_eDNA22high.mulch

# tech reps (high dens 2022)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll22)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll22)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll22)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll22, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll22, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high dens 2023)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_high.roll23)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_high.roll23)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_high.roll23)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll23, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_high.roll23, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(techreps = c(1:8,1:8),
         dens = c(rep("2022", 8), rep("2023", 8)))

(techreps_plot <- df %>%
  ggplot() +
  geom_errorbar(aes(x = techreps, ymin = ll, ymax = ul, color = dens),
                position = position_dodge(width = 1),
                width = 0) +
  geom_errorbar(aes(x = techreps, ymin = ll10, ymax = ul90, color = dens),
                position = position_dodge(width = 1),
                width = 0, linewidth = 1) +
  geom_point(aes(x = techreps, y = med, color = dens),
                position = position_dodge(width = 1),
             size = 3) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  labs(x = "Technical replicates",
       y = "Detection prob. given eDNA capture\nwithin sample (mulch)",
       color = "") +
  theme_bw() +
    guides(color = "none")
)

# num samples at 8 tech reps (high dens 2022)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.high.roll22)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.high.roll22)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.high.roll22)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll22, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll22, 2, function(x) quantile(x, 0.1)))
eDNA_preds <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds) <- c("med", "ll", "ul", "ll10", "ul90")

# tech reps (high dens 2023)
med_eDNA <- data.frame(crb_eDNA$q50$p.eDNA_detect.high.roll23)
ll_eDNA <- data.frame(crb_eDNA$q2.5$p.eDNA_detect.high.roll23)
ul_eDNA <- data.frame(crb_eDNA$q97.5$p.eDNA_detect.high.roll23)
ul90_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll23, 2, function(x) quantile(x, 0.9)))
ll10_eDNA <- 
  data.frame(apply(crb_eDNA$sims.list$p.eDNA_detect.high.roll23, 2, function(x) quantile(x, 0.1)))
eDNA_preds2 <- cbind(med_eDNA, ll_eDNA, ul_eDNA, ll10_eDNA, ul90_eDNA)*100
colnames(eDNA_preds2) <- c("med", "ll", "ul", "ll10", "ul90")

df_samps <- eDNA_preds %>%
  bind_rows(eDNA_preds2) %>%
  mutate(numsamps = c(1:20,1:20),
         dens = c(rep("2022", 20), rep("2023", 20)))

(samps_plot <- df_samps %>%
    filter(numsamps < 21) %>%
  ggplot() +
  geom_ribbon(aes(x = numsamps, ymin = ll, ymax = ul, fill = dens),
                position = position_dodge(width = 1),
              alpha = 0.5) +
  # geom_ribbon(aes(x = numsamps, ymin = ll10, ymax = ul90, fill = dens),
  #               position = position_dodge(width = 1),
  #             alpha = 0.5) +
  geom_line(aes(x = numsamps, y = med, color = dens), linewidth = 1) +
  scale_fill_manual(values = c("olivedrab", "steelblue")) +
  scale_color_manual(values = c("olivedrab", "steelblue")) +
  geom_hline(yintercept = 95, lty = 2, color = "darkgray") +
  labs(x = "No. mulch samples (at 8 tech. replicates)",
       y = "Cumulative detection probability\nat infested site (%)",
       fill = "",
       color = "") +
  theme_bw() +
  theme(text = element_text(size = 12))
)

library(patchwork)

techreps_plot + samps_plot

ggsave("figures/model_with_qPCRrep_highdensityonly_2022_2023_mulch.jpg", width = 9, height = 4, dpi = 400)
```